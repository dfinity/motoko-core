<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="../styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="../Array.html">Array</a></li></li><li><li><a href="../Blob.html">Blob</a></li></li><li><li><a href="../Bool.html">Bool</a></li></li><li><li><a href="../CertifiedData.html">CertifiedData</a></li></li><li><li><a href="../Char.html">Char</a></li></li><li><li><a href="../Cycles.html">Cycles</a></li></li><li><li><a href="../Debug.html">Debug</a></li></li><li><li><a href="../Error.html">Error</a></li></li><li><li><a href="../Float.html">Float</a></li></li><li><li><a href="../Func.html">Func</a></li></li><li><li><a href="../Int.html">Int</a></li></li><li><li><a href="../Int16.html">Int16</a></li></li><li><li><a href="../Int32.html">Int32</a></li></li><li><li><a href="../Int64.html">Int64</a></li></li><li><li><a href="../Int8.html">Int8</a></li></li><li><li><a href="../InternetComputer.html">InternetComputer</a></li></li><li><li><a href="../Iter.html">Iter</a></li></li><li><li><a href="../List.html">List</a></li></li><li><li><a href="../Map.html">Map</a></li></li><li><li><a href="../Nat.html">Nat</a></li></li><li><li><a href="../Nat16.html">Nat16</a></li></li><li><li><a href="../Nat32.html">Nat32</a></li></li><li><li><a href="../Nat64.html">Nat64</a></li></li><li><li><a href="../Nat8.html">Nat8</a></li></li><li><li><a href="../Option.html">Option</a></li></li><li><li><a href="../Order.html">Order</a></li></li><li><li><a href="../Principal.html">Principal</a></li></li><li><li><a href="../Queue.html">Queue</a></li></li><li><li><a href="../Random.html">Random</a></li></li><li><li><a href="../Region.html">Region</a></li></li><li><li><a href="../Result.html">Result</a></li></li><li><li><a href="../Runtime.html">Runtime</a></li></li><li><li><a href="../Set.html">Set</a></li></li><li><li><a href="../Stack.html">Stack</a></li></li><li><li><a href="../Text.html">Text</a></li></li><li><li><a href="../Time.html">Time</a></li></li><li><li><a href="../Timer.html">Timer</a></li></li><li><li><a href="../Types.html">Types</a></li></li><li><li><a href="../VarArray.html">VarArray</a></li></li><li><li><a href="../internal/BTreeHelper.html">internal/BTreeHelper</a></li></li><li><li><a href="../pure/List.html">pure/List</a></li></li><li><li><a href="../pure/Map.html">pure/Map</a></li></li><li><li><a href="../pure/Queue.html">pure/Queue</a></li></li><li><li><a href="../pure/Set.html">pure/Set</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Map">Map</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#isEmpty">isEmpty</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#containsKey">containsKey</a></li></li><li><li><a href="#get">get</a></li></li><li><li><a href="#add">add</a></li></li><li><li><a href="#put">put</a></li></li><li><li><a href="#replaceIfExists">replaceIfExists</a></li></li><li><li><a href="#delete">delete</a></li></li><li><li><a href="#take">take</a></li></li><li><li><a href="#maxEntry">maxEntry</a></li></li><li><li><a href="#minEntry">minEntry</a></li></li><li><li><a href="#entries">entries</a></li></li><li><li><a href="#reverseEntries">reverseEntries</a></li></li><li><li><a href="#keys">keys</a></li></li><li><li><a href="#values">values</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#map">map</a></li></li><li><li><a href="#foldLeft">foldLeft</a></li></li><li><li><a href="#foldRight">foldRight</a></li></li><li><li><a href="#all">all</a></li></li><li><li><a href="#any">any</a></li></li><li><li><a href="#singleton">singleton</a></li></li><li><li><a href="#forEach">forEach</a></li></li><li><li><a href="#filter">filter</a></li></li><li><li><a href="#filterMap">filterMap</a></li></li><li><li><a href="#assertValid">assertValid</a></li></li><li><li><a href="#toText">toText</a></li></li><li><li><a href="#equal">equal</a></li></li><li><li><a href="#compare">compare</a></li></li></ul></nav><div class="documentation"><h1>pure/Map</h1><p>Immutable, ordered key-value maps.</p>
<p>The map type is stable whenever the key and value types are stable, allowing
map values to be stored in stable variables.</p>
<p>Keys are ordered by an explicit <code>compare</code> function, which <em>must</em> be the same
across all operations on a given map.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  // creation
  let empty = Map.empty&lt;Nat, Text&gt;();
  // insertion
  let map1 = Map.add(empty, Nat.compare, 0, &quot;Zero&quot;);
  // retrieval
  let null = Map.get(empty, Nat.compare, 0);
  let ?&quot;Zero&quot; = Map.get(map1, Nat.compare, 0);
  // deletion
  let map2 = Map.delete(map1, Nat.compare, 0);
  assert not Map.isEmpty(map1);
  assert Map.isEmpty(map2);
}</code></pre>

<p>The internal representation is a red-black tree.</p>
<p>A red-black tree is a balanced binary search tree ordered by the keys.</p>
<p>The tree data structure internally colors each of its nodes either red or black,
and uses this information to balance the tree during the modifying operations.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire tree.
<code>n</code> denotes the number of key-value entries (i.e. nodes) stored in the tree.</li></ul>

<p>Note:</p>
<ul><li>Map operations, such as retrieval, insertion, and removal create <code>O(log(n))</code> temporary objects that become garbage.</li></ul>

<p>Credits:</p>
<p>The core of this implementation is derived from:</p>
<ul><li>Ken Friis Larsen's <a href="https://github.com/kfl/mosml/blob/master/src/mosmllib/Redblackmap.sml">RedBlackMap.sml</a>, which itself is based on:</li><li>Stefan Kahrs, &quot;Red-black trees with types&quot;, Journal of Functional Programming, 11(4): 425-432 (2001), <a href="http://www.cs.ukc.ac.uk/people/staff/smk/redblack/rb.html">version 1 in web appendix</a>.</li></ul><div class="declaration"><h4 class="type-declaration" id="type.Map"><span class="keyword">type </span><span class="type">Map</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = <a href="../Types.html#Pure.type.Map"><span class="type">Types.Pure.Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</h4><p></p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;() : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Create a new empty immutable key-value map.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.empty&lt;Nat, Text&gt;();
  Debug.print(Nat.toText(Map.size(map))); // prints `0`
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Bool</span></code></h4><p><p>Determines whether a key-value map is empty.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map0 = Map.empty&lt;Nat, Text&gt;();
  let map1 = Map.add(map0, Nat.compare, 0, &quot;Zero&quot;);

  Debug.print(debug_show(Map.isEmpty(map0))); // prints `true`
  Debug.print(debug_show(Map.isEmpty(map1))); // prints `false`
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Determine the size of the map as the number of key-value entries.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

Debug.print(debug_show(Map.size(map)));
// 3</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="containsKey"><code><span class="keyword">public func </span><span class="fnname">containsKey</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">key</span> : <span class="type">K</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Test whether the map <code>map</code>, ordered by <code>compare</code>, contains a binding for the given <code>key</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  Debug.print(debug_show Map.containsKey(map, Nat.compare, 1)); // =&gt; true
  Debug.print(debug_show Map.containsKey(map, Nat.compare, 42)); // =&gt; false
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="get"><code><span class="keyword">public func </span><span class="fnname">get</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">key</span> : <span class="type">K</span><br/>) : ?<span class="type">V</span></code></h4><p><p>Given, <code>map</code> ordered by <code>compare</code>, return the value associated with key <code>key</code> if present and <code>null</code> otherwise.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  Debug.print(debug_show(Map.get(map, Nat.compare, 1)));
  // ?&quot;One&quot;
  Debug.print(debug_show(Map.get(map, Nat.compare, 42)));
  // null
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="add"><code><span class="keyword">public func </span><span class="fnname">add</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">key</span> : <span class="type">K</span>, <br/>  <span class="parameter">value</span> : <span class="type">V</span><br/>) : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Given <code>map</code> ordered by <code>compare</code>, add a mapping from <code>key</code> to <code>value</code>. Overwrites any existing entry with key <code>key</code>.
Returns a modified map.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  var map = Map.empty&lt;Nat, Text&gt;();

  map := Map.add(map, Nat.compare, 0, &quot;Zero&quot;);
  map := Map.add(map, Nat.compare, 2, &quot;Two&quot;);
  map := Map.add(map, Nat.compare, 1, &quot;One&quot;);

  Debug.print(debug_show(Iter.toArray(map.entries(map))));
  // [(0, &quot;Zero&quot;), (1, &quot;One&quot;), (2, &quot;Two&quot;)]
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code>.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: The returned map shares with the <code>m</code> most of the tree nodes.
Garbage collecting one of maps (e.g. after an assignment <code>m := Map.add(m, cmp, k, v)</code>)
causes collecting <code>O(log(n))</code> nodes.</p>
</p></div><div class="declaration"><h4 class="function" id="put"><code><span class="keyword">public func </span><span class="fnname">put</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">key</span> : <span class="type">K</span>, <br/>  <span class="parameter">value</span> : <span class="type">V</span><br/>) : (<a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>Given <code>map</code> ordered by <code>compare</code>, add a mapping from <code>key</code> to <code>value</code>. Overwrites any existing entry with key <code>key</code>.
Returns the modified map and the previous value associated with key <code>key</code>
or <code>null</code> if no such value exists.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map0 = natMap.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]),
    Nat.compare);

  let (map1, old1) = Map.put(map0, Nat.compare, 0, &quot;Nil&quot;);

  Debug.print(debug_show(Iter.toArray(natMap.entries(map1))));
  Debug.print(debug_show(old1));
  // [(0, &quot;Nil&quot;), (1, &quot;One&quot;), (2, &quot;Two&quot;)]
  // ?&quot;Zero&quot;

  let (map2, old2) = natMap.put(map0, Nat.compare, 3, &quot;Three&quot;);

  Debug.print(debug_show(Iter.toArray(natMap.entries(map2))));
  Debug.print(debug_show(old2));
  // [(0, &quot;Zero&quot;), (1, &quot;One&quot;), (2, &quot;Two&quot;), (3, &quot;Three&quot;)]
  // null
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: The returned map shares with the <code>m</code> most of the tree nodes.
Garbage collecting one of maps (e.g. after an assignment <code>m := Map.put(m, Nat.compare, k, v).0</code>)
causes collecting <code>O(log(n))</code> nodes.</p>
</p></div><div class="declaration"><h4 class="function" id="replaceIfExists"><code><span class="keyword">public func </span><span class="fnname">replaceIfExists</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">key</span> : <span class="type">K</span>, <br/>  <span class="parameter">value</span> : <span class="type">V</span><br/>) : (<a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>Overwrites the value of an existing key and returns the updated map and previous value.
If the key does not exist, returns the original map and <code>null</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let singleton = Map.singleton(0, &quot;Null&quot;);

  let (map1, oldZero) = Map.replaceIfExists(singleton, Nat.compare, 0, &quot;Zero&quot;); // overwrites the value for existing key.
  Debug.print(debug_show(oldZero)); // prints `?&quot;Null&quot;`, previous value.
  Debug.print(debug_show(Map.get(map1, Nat.compare, 0))); // prints `?&quot;Zero&quot;`, new value.
  let empty = Map.empty&lt;Nat, Text&gt;();
  let (map2, oldOne) = Map.replaceIfExists(empty, Nat.compare, 1, &quot;One&quot;);  // no effect, key is absent
  Debug.print(debug_show(oldOne)); // prints `null`, key was absent.
  Debug.print(debug_show(Map.get(map2, Nat.compare, 0))); // prints `null`
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code>.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="delete"><code><span class="keyword">public func </span><span class="fnname">delete</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">key</span> : <span class="type">K</span><br/>) : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Given a <code>map</code>, ordered by <code>compare</code>, deletes the entry for <code>key</code> from <code>map</code>. Has no effect if <code>key</code> is not
present in the map. Returns a modified map, leaving <code>map</code> unchanged.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  Debug.print(debug_show(Iter.toArray(Map.entries(Map.delete(map, Nat.compare, 1)))));
  Debug.print(debug_show(Iter.toArray(Map.entries(Map.delete(map, Nat.compare, 42)))));

  // [(0, &quot;Zero&quot;), (2, &quot;Two&quot;)]
  // [(0, &quot;Zero&quot;), (1, &quot;One&quot;), (2, &quot;Two&quot;)]
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code>
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: The returned map shares with the <code>m</code> most of the tree nodes.
Garbage collecting one of maps (e.g. after an assignment <code>map := Map.delete(map, compare, k).0</code>)
causes collecting <code>O(log(n))</code> nodes.</p>
</p></div><div class="declaration"><h4 class="function" id="take"><code><span class="keyword">public func </span><span class="fnname">take</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">key</span> : <span class="type">K</span><br/>) : (<a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>Given a <code>map</code>, ordered by <code>compare</code>, deletes the entry for <code>key</code>. Returns a modified map, leaving <code>map</code> unchanged, and the
previous value associated with <code>key</code> or <code>null</code> if no such value exists.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map0 = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  let (map1, old1) = Map.take(map0, Nat.compare, 0);

  Debug.print(debug_show(Iter.toArray(Map.entries(map1))));
  Debug.print(debug_show(old1));
  // [(1, &quot;One&quot;), (2, &quot;Two&quot;)]
  // ?&quot;Zero&quot;

  let (map2, old2) = Map.take(map0, Nat.compare, 42);

  Debug.print(debug_show(Iter.toArray(Map.entries(map2))));
  Debug.print(debug_show(old2));
  // [(0, &quot;Zero&quot;), (1, &quot;One&quot;), (2, &quot;Two&quot;)]
  // null
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code>.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: The returned map shares with the <code>m</code> most of the tree nodes.
Garbage collecting one of maps (e.g. after an assignment <code>map := Map.remove(map, compare, key)</code>)
causes collecting <code>O(log(n))</code> nodes.</p>
</p></div><div class="declaration"><h4 class="function" id="maxEntry"><code><span class="keyword">public func </span><span class="fnname">maxEntry</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : ?(<span class="type">K</span>, <span class="type">V</span>)</code></h4><p><p>Given a <code>map</code> retrieves the key-value pair in <code>map</code> with a maximal key. If <code>map</code> is empty returns <code>null</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  Debug.print(debug_show(Map.maxEntry(map)));
  Debug.print(debug_show(Map.maxEntry(Map.empty&lt;Nat, Text&gt;())));
  // null
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
</p></div><div class="declaration"><h4 class="function" id="minEntry"><code><span class="keyword">public func </span><span class="fnname">minEntry</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : ?(<span class="type">K</span>, <span class="type">V</span>)</code></h4><p><p>Retrieves a key-value pair from <code>map</code> with the minimal key. If the map is empty returns <code>null</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  Debug.print(debug_show(Map.minEntry(map)));
  // ?(0, &quot;Zero&quot;)
  Debug.print(debug_show(Map.minEntry(Map.empty())));
   // =&gt; null
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
</p></div><div class="declaration"><h4 class="function" id="entries"><code><span class="keyword">public func </span><span class="fnname">entries</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;</code></h4><p><p>Returns an Iterator (<code>Iter</code>) over the key-value pairs in the map.
Iterator provides a single method <code>next()</code>, which returns
pairs in ascending order by keys, or <code>null</code> when out of pairs to iterate over.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  Debug.print(debug_show(Iter.toArray(Map.entries(map))));
  // [(0, &quot;Zero&quot;), (1, &quot;One&quot;), (2, &quot;Two&quot;)]
  var sum = 0;
  for ((k, _) in Map.entries(map)) { sum += k; };
  Debug.print(debug_show(sum));
  // 3
}</code></pre><p>Cost of iteration over all elements:
Runtime: <code>O(n)</code>.
Space: <code>O(log(n))</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
<p>Note: Full map iteration creates <code>O(n)</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="reverseEntries"><code><span class="keyword">public func </span><span class="fnname">reverseEntries</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;</code></h4><p><p>Same as <code>entries</code> but iterates in descending order.</p>
</p></div><div class="declaration"><h4 class="function" id="keys"><code><span class="keyword">public func </span><span class="fnname">keys</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">K</span>&gt;</code></h4><p><p>Given a <code>map</code>, returns an Iterator (<code>Iter</code>) over the keys of the <code>map</code>.
Iterator provides a single method <code>next()</code>, which returns
keys in ascending order, or <code>null</code> when out of keys to iterate over.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]),
  Nat.compare);

  Debug.print(debug_show(Iter.toArray(Map.keys(map))));
  // [0, 1, 2]
}</code></pre><p>Cost of iteration over all elements:
Runtime: <code>O(n)</code>.
Space: <code>O(log(n))</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
<p>Note: Full map iteration creates <code>O(n)</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="values"><code><span class="keyword">public func </span><span class="fnname">values</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">V</span>&gt;</code></h4><p><p>Given a <code>map</code>, returns an Iterator (<code>Iter</code>) over the values of the map.
Iterator provides a single method <code>next()</code>, which returns
values in ascending order of associated keys, or <code>null</code> when out of values to iterate over.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
let map = Map.fromIter&lt;Nat, Text&gt;(
  Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]),
  Nat.compare);

  Debug.print(debug_show(Iter.toArray(Map.values(map))));
  // [&quot;Zero&quot;, &quot;One&quot;, &quot;Two&quot;]
}</code></pre><p>Cost of iteration over all elements:
Runtime: <code>O(n)</code>.
Space: <code>O(log(n))</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
<p>Note: Full map iteration creates <code>O(n)</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">iter</span> : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;(<span class="type">K</span>, <span class="type">V</span>)&gt;, <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>) : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Returns a new map, containing all entries given by the iterator <code>i</code>.
If there are multiple entries with the same key the last one is taken.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  Debug.print(debug_show(Iter.toArray(Map.entries(map))));
  // [(0, &quot;Zero&quot;), (1, &quot;One&quot;), (2, &quot;Two&quot;)]
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(n)</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: Creates <code>O(n * log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="map"><code><span class="keyword">public func </span><span class="fnname">map</span>&lt;<span class="type">K</span>, <span class="type">V1</span>, <span class="type">V2</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V1</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V1</span>) -&gt; <span class="type">V2</span>) : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V2</span>&gt;</code></h4><p><p>Given a <code>map</code> and function <code>f</code>, creates a new map by applying <code>f</code> to each entry in the map <code>m</code>. Each entry
<code>(k, v)</code> in the old map is transformed into a new entry <code>(k, v2)</code>, where
the new value <code>v2</code> is created by applying <code>f</code> to <code>(k, v)</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]),
    Nat.compare);

  func f(key : Nat, _val : Text) : Nat = key * 2;

  let resMap = Map.map(map, f);

  Debug.print(debug_show(Iter.toArray(Map.entries(resMap))));
  // [(0, 0), (1, 2), (2, 4)]
}</code></pre>

<p>Cost of mapping all the elements:
Runtime: <code>O(n)</code>.
Space: <code>O(n)</code> retained memory
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
</p></div><div class="declaration"><h4 class="function" id="foldLeft"><code><span class="keyword">public func </span><span class="fnname">foldLeft</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">A</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">A</span>, <span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Collapses the elements in the <code>map</code> into a single value by starting with <code>base</code>
and progressively combining keys and values into <code>base</code> with <code>combine</code>. Iteration runs
left to right.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);

  func folder(accum : (Nat, Text), key : Nat, val : Text) : ((Nat, Text))
    = (key + accum.0, accum.1 # val);

  Debug.print(debug_show(Map.foldLeft(map, (0, &quot;&quot;), folder)));
  // (3, &quot;ZeroOneTwo&quot;)
}</code></pre>

<p>Cost of iteration over all elements:
Runtime: <code>O(n)</code>.
Space: depends on <code>combine</code> function plus garbage, see the note below.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
<p>Note: Full map iteration creates <code>O(n)</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="foldRight"><code><span class="keyword">public func </span><span class="fnname">foldRight</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">A</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">K</span>, <span class="type">V</span>, <span class="type">A</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Collapses the elements in the <code>map</code> into a single value by starting with <code>base</code>
and progressively combining keys and values into <code>base</code> with <code>combine</code>. Iteration runs
right to left.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]),
    Nat.compare);

  func folder(key : Nat, val : Text, accum : (Nat, Text)) : ((Nat, Text))
    = (key + accum.0, accum.1 # val);

  Debug.print(debug_show(Map.foldRight(map, (0, &quot;&quot;), folder)));
  // (3, &quot;TwoOneZero&quot;)
}</code></pre>

<p>Cost of iteration over all elements:
Runtime: <code>O(n)</code>.
Space: depends on <code>combine</code> function plus garbage, see the note below.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
<p>Note: Full map iteration creates <code>O(n)</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="all"><code><span class="keyword">public func </span><span class="fnname">all</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">pred</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Test whether all key-value pairs in <code>map</code> satisfy the given predicate <code>pred</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;0&quot;), (2, &quot;2&quot;), (1, &quot;1&quot;)]),
    Nat.compare);

  Debug.print(debug_show(Map.all&lt;Text&gt;(map, func (k, v) = (v == debug_show(k)))));
  // true
  Debug.print(debug_show(Map.all&lt;Text&gt;(map, func (k, v) = (k &lt; 2))));
  // false
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
</p></div><div class="declaration"><h4 class="function" id="any"><code><span class="keyword">public func </span><span class="fnname">any</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">pred</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Test if any key-value pair in <code>map</code> satisfies the given predicate <code>pred</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;0&quot;), (2, &quot;2&quot;), (1, &quot;1&quot;)]),
    Nat.compare);

  Debug.print(debug_show(Map.any&lt;Text&gt;(map, func (k, v) = (k &gt;= 3))));
  // false
  Debug.print(debug_show(Map.any&lt;Text&gt;(map, func (k, v) = (k &gt;= 0))));
  // true
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
</p></div><div class="declaration"><h4 class="function" id="singleton"><code><span class="keyword">public func </span><span class="fnname">singleton</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">key</span> : <span class="type">K</span>, <span class="parameter">value</span> : <span class="type">V</span>) : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Create a new immutable key-value <code>map</code> with a single entry.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let cityCodes = Map.singleton&lt;Text, Nat&gt;(&quot;Zurich&quot;, 8000);
  Debug.print(debug_show(Map.size(cityCodes)));
  // 1
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="forEach"><code><span class="keyword">public func </span><span class="fnname">forEach</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">operation</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; ())</code></h4><p><p>Apply an operation for each key-value pair contained in the map.
The operation is applied in ascending order of the keys.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]),
    Nat.compare);
  Map.forEach&lt;Nat, Text&gt;(map, func (key, value) {
    Debug.print(&quot;key=&quot; # Nat.toText(key) # &quot;, value='&quot; # value # &quot;'&quot;);
  })
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of key-value entries stored in the map.</p>
</p></div><div class="declaration"><h4 class="function" id="filter"><code><span class="keyword">public func </span><span class="fnname">filter</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">criterion</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span><br/>) : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Filter entries in a new map.
Returns a new map that only contains the key-value pairs
that fulfil the criterion function.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let numberNames = Map.fromIter&lt;Nat, Text&gt;(Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]), Nat.compare);
  let evenNames = Map.filter&lt;Nat, Text&gt;(numberNames, Nat.compare, func (key, value) {
    key % 2 == 0
  });
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(n)</code>.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="filterMap"><code><span class="keyword">public func </span><span class="fnname">filterMap</span>&lt;<span class="type">K</span>, <span class="type">V1</span>, <span class="type">V2</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V1</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V1</span>) -&gt; ?<span class="type">V2</span><br/>) : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V2</span>&gt;</code></h4><p><p>Given a <code>map</code>, comparison <code>compare</code> and function <code>f</code>,
constructs a new map ordered by <code>compare</code>, by applying <code>f</code> to each entry in <code>map</code>.
For each entry <code>(k, v)</code> in the old map, if <code>f</code> evaluates to <code>null</code>, the entry is discarded.
Otherwise, the entry is transformed into a new entry <code>(k, v2)</code>, where
the new value <code>v2</code> is the result of applying <code>f</code> to <code>(k, v)</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]),
    Nat.compare);

  func f(key : Nat, val : Text) : ?Text {
    if(key == 0) {null}
    else { ?(&quot;Twenty &quot; # val)}
  };

  let newMap = Map.filterMap(map, Nat.compare, f);

  Debug.print(debug_show(Iter.toArray(Map.entries(newMap))));
  // [(1, &quot;Twenty One&quot;), (2, &quot;Twenty Two&quot;)]
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(n)</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: Creates <code>O(n * log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="assertValid"><code><span class="keyword">public func </span><span class="fnname">assertValid</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">compare</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>) : ()</code></h4><p><p>Validate the representation invariants of the given <code>map</code>.
Assert if any invariants are violated.</p>
</p></div><div class="declaration"><h4 class="function" id="toText"><code><span class="keyword">public func </span><span class="fnname">toText</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">keyFormat</span> : <span class="type">K</span> -&gt; <span class="type">Text</span>, <br/>  <span class="parameter">valueFormat</span> : <span class="type">V</span> -&gt; <span class="type">Text</span><br/>) : <span class="type">Text</span></code></h4><p><p>Converts the <code>map</code> to its textual representation using <code>keyFormat</code> and <code>valueFormat</code> to convert each key and value to <code>Text</code>.</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let map = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;), (1, &quot;One&quot;)]),
    Nat.compare);
  Map.toText&lt;Nat, Text&gt;(map, Nat.toText, func t { t })
   // =&gt; &quot;{(0, Zero), (1, One), (2, Two)}&quot;
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>keyFormat</code> and <code>valueFormat</code> run in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="equal"><code><span class="keyword">public func </span><span class="fnname">equal</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map1</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">map2</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">equalKey</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">equalValue</span> : (<span class="type">V</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Test whether two immutable maps have equal entries.
Assumes both maps are ordered equivalently.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;
import Text &quot;mo:base/Text&quot;;

persistent actor {
  let map1 = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (1, &quot;One&quot;), (2, &quot;Two&quot;)]),
    Nat.compare);
  let map2 = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(2, &quot;Two&quot;), (1, &quot;One&quot;), (0, &quot;Zero&quot;)]),
    Nat.compare);
  assert(Map.equal(map1, map2, Nat.equal, Text.equal));
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="compare"><code><span class="keyword">public func </span><span class="fnname">compare</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">map1</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">map2</span> : <a href="#type.Map"><span class="type">Map</span></a>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">compareKey</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">compareValue</span> : (<span class="type">V</span>, <span class="type">V</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a></code></h4><p><p>Compare two maps by primarily comparing keys and secondarily values.
Both maps are iterated by the ascending order of their creation and
order is determined by the following rules:
Less:
<code>map1</code> is less than <code>map2</code> if:</p>
<ul><li>the pairwise iteration hits a entry pair <code>entry1</code> and <code>entry2</code> where
 <code>entry1</code> is less than <code>entry2</code> and all preceding entry pairs are equal, or,</li><li><code>map1</code> is  a strict prefix of <code>map2</code>, i.e. <code>map2</code> has more entries than <code>map1</code>
 and all entries of <code>map1</code> occur at the beginning of iteration <code>map2</code>.
<code>entry1</code> is less than <code>entry2</code> if:</li><li>the key of <code>entry1</code> is less than the key of <code>entry2</code>, or</li><li><code>entry1</code> and <code>entry2</code> have equal keys and the value of <code>entry1</code> is less than
 the value of <code>entry2</code>.
Equal:
<code>map1</code> and <code>map2</code> have same series of equal entries by pairwise iteration.
Greater:
<code>map1</code> is neither less nor equal <code>map2</code>.</li></ul>

<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:base/pure/Map&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Text &quot;mo:base/Text&quot;;

persistent actor {
  let map1 = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (1, &quot;One&quot;)]),
    Nat.compare);
  let map2 = Map.fromIter&lt;Nat, Text&gt;(
    Iter.fromArray([(0, &quot;Zero&quot;), (2, &quot;Two&quot;)]),
    Nat.compare);

  let orderLess = Map.compare(map1, map2, Nat.compare, Text.compare);
  // `#less`
  let orderEqual = Map.compare(map1, map1, Nat.compare, Text.compare);
  // `#equal`
  let orderGreater = Map.compare(map2, map1, Nat.compare, Text.compare);
  // `#greater`
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of key-value entries stored in the map and
assuming that <code>compareKey</code> and <code>compareValue</code> have runtime and space costs of <code>O(1)</code>.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div></div></body></html>