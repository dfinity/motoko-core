<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Array.html">Array</a></li></li><li><li><a href="Blob.html">Blob</a></li></li><li><li><a href="Bool.html">Bool</a></li></li><li><li><a href="CertifiedData.html">CertifiedData</a></li></li><li><li><a href="Char.html">Char</a></li></li><li><li><a href="Cycles.html">Cycles</a></li></li><li><li><a href="Debug.html">Debug</a></li></li><li><li><a href="Error.html">Error</a></li></li><li><li><a href="Float.html">Float</a></li></li><li><li><a href="Func.html">Func</a></li></li><li><li><a href="Int.html">Int</a></li></li><li><li><a href="Int16.html">Int16</a></li></li><li><li><a href="Int32.html">Int32</a></li></li><li><li><a href="Int64.html">Int64</a></li></li><li><li><a href="Int8.html">Int8</a></li></li><li><li><a href="InternetComputer.html">InternetComputer</a></li></li><li><li><a href="Iter.html">Iter</a></li></li><li><li><a href="List.html">List</a></li></li><li><li><a href="Map.html">Map</a></li></li><li><li><a href="Nat.html">Nat</a></li></li><li><li><a href="Nat16.html">Nat16</a></li></li><li><li><a href="Nat32.html">Nat32</a></li></li><li><li><a href="Nat64.html">Nat64</a></li></li><li><li><a href="Nat8.html">Nat8</a></li></li><li><li><a href="Option.html">Option</a></li></li><li><li><a href="Order.html">Order</a></li></li><li><li><a href="Principal.html">Principal</a></li></li><li><li><a href="Queue.html">Queue</a></li></li><li><li><a href="Random.html">Random</a></li></li><li><li><a href="Region.html">Region</a></li></li><li><li><a href="Result.html">Result</a></li></li><li><li><a href="Runtime.html">Runtime</a></li></li><li><li><a href="Set.html">Set</a></li></li><li><li><a href="Stack.html">Stack</a></li></li><li><li><a href="Text.html">Text</a></li></li><li><li><a href="Time.html">Time</a></li></li><li><li><a href="Timer.html">Timer</a></li></li><li><li><a href="Types.html">Types</a></li></li><li><li><a href="VarArray.html">VarArray</a></li></li><li><li><a href="internal/BTreeHelper.html">internal/BTreeHelper</a></li></li><li><li><a href="pure/List.html">pure/List</a></li></li><li><li><a href="pure/Map.html">pure/Map</a></li></li><li><li><a href="pure/Queue.html">pure/Queue</a></li></li><li><li><a href="pure/Set.html">pure/Set</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#balance">balance</a></li></li><li><li><a href="#available">available</a></li></li><li><li><a href="#accept">accept</a></li></li><li><li><a href="#add">add</a></li></li><li><li><a href="#refunded">refunded</a></li></li></ul></nav><div class="documentation"><h1>Cycles</h1><p>Managing cycles within actors in the Internet Computer Protocol (ICP).</p>
<p>The usage of the Internet Computer is measured, and paid for, in <em>cycles</em>.
This library provides imperative operations for observing cycles, transferring cycles, and
observing refunds of cycles.</p>
<p><strong>NOTE:</strong> Since cycles measure computational resources, the value of  <code>balance()</code> can change from one call to the next.</p>
<p>Cycles can be transferred from the current actor to another actor with the evaluation of certain forms of expression.
In particular, the expression must be a call to a shared function, a call to a local function with an <code>async</code> return type, or a simple <code>async</code> expression. 
To attach an amount of cycles to an expression, simply prefix the expression <code>&lt;exp&gt; with </code>(with cycles = &lt;amount&gt;)<code>, that is </code>(with cycles = &lt;amount&gt;) &lt;exp&gt;<code>. 

**NOTE:** Attaching cycles will trap if the amount specified exceeds </code>2 ** 128<code>cycles.

Upon the call, but not before, the amount of cycles is deducted from</code>balance()<code>.
If this total exceeds </code>balance()<code>, the caller traps, aborting the call without consuming the cycles.
Note that attaching cycles to a call to a local function call or </code>async` expression just transfers cycles from the current actor to itself.</p>
<p>Example for use on the ICP:</p>
<pre><code>motoko no-repl
import Cycles &quot;mo:base/Cycles&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor {
  public func main() : async() {
    Debug.print(&quot;Main balance: &quot; # debug_show(Cycles.balance()));
    await (with cycles = 15_000_000) operation(); // accepts 10_000_000 cycles
    Debug.print(&quot;Main refunded: &quot; # debug_show(Cycles.refunded())); // 5_000_000
    Debug.print(&quot;Main balance: &quot; # debug_show(Cycles.balance())); // decreased by around 10_000_000
  };

  func operation() : async() {
    Debug.print(&quot;Operation balance: &quot; # debug_show(Cycles.balance()));
    Debug.print(&quot;Operation available: &quot; # debug_show(Cycles.available()));
    let obtained = Cycles.accept&lt;system&gt;(10_000_000);
    Debug.print(&quot;Operation obtained: &quot; # debug_show(obtained)); // =&gt; 10_000_000
    Debug.print(&quot;Operation balance: &quot; # debug_show(Cycles.balance())); // increased by 10_000_000
    Debug.print(&quot;Operation available: &quot; # debug_show(Cycles.available())); // decreased by 10_000_000
  }
}</code></pre><div class="declaration"><h4 class="value-declaration" id="balance"><code><span class="keyword">public </span><span class="keyword">let </span><span class="fnname">balance</span> : () -&gt; (<span class="parameter">amount</span> : <span class="type">Nat</span>)</code></h4><p><p>Returns the actor's current balance of cycles as <code>amount</code>.</p>
<p>Example for use on the ICP:</p>
<pre><code>motoko no-repl
import Cycles &quot;mo:base/Cycles&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor {
  public func main() : async() {
    let balance = Cycles.balance();
    Debug.print(&quot;Balance: &quot; # debug_show(balance));
  }
}</code></pre></p></div><div class="declaration"><h4 class="value-declaration" id="available"><code><span class="keyword">public </span><span class="keyword">let </span><span class="fnname">available</span> : () -&gt; (<span class="parameter">amount</span> : <span class="type">Nat</span>)</code></h4><p><p>Returns the currently available <code>amount</code> of cycles.
The amount available is the amount received in the current call,
minus the cumulative amount <code>accept</code>ed by this call.
On exit from the current shared function or async expression via <code>return</code> or <code>throw</code>,
any remaining available amount is automatically refunded to the caller/context.</p>
<p>Example for use on the ICP:</p>
<pre><code>motoko no-repl
import Cycles &quot;mo:base/Cycles&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor {
  public func main() : async() {
    let available = Cycles.available();
    Debug.print(&quot;Available: &quot; # debug_show(available));
  }
}</code></pre></p></div><div class="declaration"><h4 class="value-declaration" id="accept"><code><span class="keyword">public </span><span class="keyword">let </span><span class="fnname">accept</span> : (<span class="parameter">amount</span> : <span class="type">Nat</span>) -&gt; (<span class="parameter">accepted</span> : <span class="type">Nat</span>)</code></h4><p><p>Transfers up to <code>amount</code> from <code>available()</code> to <code>balance()</code>.
Returns the amount actually transferred, which may be less than
requested, for example, if less is available, or if canister balance limits are reached.</p>
<p>Example for use on the ICP (for simplicity, only transferring cycles to itself):</p>
<pre><code>motoko no-repl
import Cycles &quot;mo:base/Cycles&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor {
  public func main() : async() {
    await (with cycles = 15_000_000) operation(); // accepts 10_000_000 cycles
  };

  func operation() : async() {
    let obtained = Cycles.accept&lt;system&gt;(10_000_000);
    Debug.print(&quot;Obtained: &quot; # debug_show(obtained)); // =&gt; 10_000_000
  }
}</code></pre></p></div><div class="declaration"><h4 class="value-declaration" id="add"><code><span class="keyword">public </span><span class="keyword">let </span><span class="fnname">add</span> : (<span class="parameter">amount</span> : <span class="type">Nat</span>) -&gt; ()</code></h4><p><p>Indicates additional <code>amount</code> of cycles to be transferred in
the next call, that is, evaluation of a shared function call or
async expression.
Traps if the current total would exceed <code>2 ** 128</code> cycles.
Upon the call, but not before, the total amount of cycles <code>add</code>ed since
the last call is deducted from <code>balance()</code>.
If this total exceeds <code>balance()</code>, the caller traps, aborting the call.</p>
<p><strong>Note</strong>: The implicit register of added amounts is reset to zero on entry to
a shared function and after each shared function call or resume from an await.</p>
<p>Example for use on the ICP (for simplicity, only transferring cycles to itself):</p>
<pre><code>motoko no-repl
import Cycles &quot;mo:base/Cycles&quot;;

actor {
  func operation() : async() {
    ignore Cycles.accept&lt;system&gt;(10_000_000);
  };

  public func main() : async() {
    await (with cycles = 15_000_000) operation();
  }
}</code></pre></p></div><div class="declaration"><h4 class="value-declaration" id="refunded"><code><span class="keyword">public </span><span class="keyword">let </span><span class="fnname">refunded</span> : () -&gt; (<span class="parameter">amount</span> : <span class="type">Nat</span>)</code></h4><p><p>Reports <code>amount</code> of cycles refunded in the last <code>await</code> of the current
context, or zero if no await has occurred yet.
Calling <code>refunded()</code> is solely informational and does not affect <code>balance()</code>.
Instead, refunds are automatically added to the current balance,
whether or not <code>refunded</code> is used to observe them.</p>
<p>Example for use on the ICP (for simplicity, only transferring cycles to itself):</p>
<pre><code>motoko no-repl
import Cycles &quot;mo:base/Cycles&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor {
  func operation() : async() {
    ignore Cycles.accept&lt;system&gt;(10_000_000);
  };

  public func main() : async() {
    await (with cycles = 15_000_000) operation(); // accepts 10_000_000 cycles
    Debug.print(&quot;Refunded: &quot; # debug_show(Cycles.refunded())); // 5_000_000
  }
}</code></pre></p></div></div></body></html>