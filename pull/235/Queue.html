<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Array.html">Array</a></li></li><li><li><a href="Blob.html">Blob</a></li></li><li><li><a href="Bool.html">Bool</a></li></li><li><li><a href="CertifiedData.html">CertifiedData</a></li></li><li><li><a href="Char.html">Char</a></li></li><li><li><a href="Cycles.html">Cycles</a></li></li><li><li><a href="Debug.html">Debug</a></li></li><li><li><a href="Error.html">Error</a></li></li><li><li><a href="Float.html">Float</a></li></li><li><li><a href="Func.html">Func</a></li></li><li><li><a href="Int.html">Int</a></li></li><li><li><a href="Int16.html">Int16</a></li></li><li><li><a href="Int32.html">Int32</a></li></li><li><li><a href="Int64.html">Int64</a></li></li><li><li><a href="Int8.html">Int8</a></li></li><li><li><a href="InternetComputer.html">InternetComputer</a></li></li><li><li><a href="Iter.html">Iter</a></li></li><li><li><a href="List.html">List</a></li></li><li><li><a href="Map.html">Map</a></li></li><li><li><a href="Nat.html">Nat</a></li></li><li><li><a href="Nat16.html">Nat16</a></li></li><li><li><a href="Nat32.html">Nat32</a></li></li><li><li><a href="Nat64.html">Nat64</a></li></li><li><li><a href="Nat8.html">Nat8</a></li></li><li><li><a href="Option.html">Option</a></li></li><li><li><a href="Order.html">Order</a></li></li><li><li><a href="Principal.html">Principal</a></li></li><li><li><a href="Queue.html">Queue</a></li></li><li><li><a href="Random.html">Random</a></li></li><li><li><a href="Region.html">Region</a></li></li><li><li><a href="Result.html">Result</a></li></li><li><li><a href="Runtime.html">Runtime</a></li></li><li><li><a href="Set.html">Set</a></li></li><li><li><a href="Stack.html">Stack</a></li></li><li><li><a href="Text.html">Text</a></li></li><li><li><a href="Time.html">Time</a></li></li><li><li><a href="Timer.html">Timer</a></li></li><li><li><a href="Tuples.html">Tuples</a></li></li><li><li><a href="Types.html">Types</a></li></li><li><li><a href="VarArray.html">VarArray</a></li></li><li><li><a href="internal/BTreeHelper.html">internal/BTreeHelper</a></li></li><li><li><a href="internal/PRNG.html">internal/PRNG</a></li></li><li><li><a href="pure/List.html">pure/List</a></li></li><li><li><a href="pure/Map.html">pure/Map</a></li></li><li><li><a href="pure/OldQueue.html">pure/OldQueue</a></li></li><li><li><a href="pure/Queue.html">pure/Queue</a></li></li><li><li><a href="pure/RealTimeQueue.html">pure/RealTimeQueue</a></li></li><li><li><a href="pure/Set.html">pure/Set</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Queue">Queue</a></li></li><li><li><a href="#toPure">toPure</a></li></li><li><li><a href="#fromPure">fromPure</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#singleton">singleton</a></li></li><li><li><a href="#clear">clear</a></li></li><li><li><a href="#clone">clone</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#isEmpty">isEmpty</a></li></li><li><li><a href="#contains">contains</a></li></li><li><li><a href="#peekFront">peekFront</a></li></li><li><li><a href="#peekBack">peekBack</a></li></li><li><li><a href="#pushFront">pushFront</a></li></li><li><li><a href="#pushBack">pushBack</a></li></li><li><li><a href="#popFront">popFront</a></li></li><li><li><a href="#popBack">popBack</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#values">values</a></li></li><li><li><a href="#all">all</a></li></li><li><li><a href="#any">any</a></li></li><li><li><a href="#forEach">forEach</a></li></li><li><li><a href="#map">map</a></li></li><li><li><a href="#filter">filter</a></li></li><li><li><a href="#filterMap">filterMap</a></li></li><li><li><a href="#equal">equal</a></li></li><li><li><a href="#toText">toText</a></li></li><li><li><a href="#compare">compare</a></li></li></ul></nav><div class="documentation"><h1>Queue</h1><p>A mutable double-ended queue of elements.
The queue has two ends, front and back.
Elements can be added and removed at the two ends.</p>
<p>This can be used for different use cases, such as:</p>
<ul><li>Queue (FIFO) by using <code>pushBack()</code> and <code>popFront()</code></li><li>Stack (LIFO) by using <code>pushFront()</code> and <code>popFront()</code>.</li></ul>

<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let orders = Queue.empty&lt;Text&gt;();
  Queue.pushBack(orders, &quot;Motoko&quot;);
  Queue.pushBack(orders, &quot;Mops&quot;);
  Queue.pushBack(orders, &quot;IC&quot;);
  assert Queue.popFront(orders) == ?&quot;Motoko&quot;;
  assert Queue.popFront(orders) == ?&quot;Mops&quot;;
  assert Queue.popFront(orders) == ?&quot;IC&quot;;
  assert Queue.popFront(orders) == null;
}</code></pre>

<p>The internal implementation is a doubly-linked list.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(1)</code> for push, pop, and peek operations.</li><li>Space: <code>O(n)</code>.
<code>n</code> denotes the number of elements stored in the queue.</li></ul><div class="declaration"><h4 class="type-declaration" id="type.Queue"><span class="keyword">type </span><span class="type">Queue</span>&lt;<span class="type">T</span>&gt; = <a href="Types.html#Queue.type.Queue"><span class="type">Types.Queue.Queue</span></a>&lt;<span class="type">T</span>&gt;</h4><p></p></div><div class="declaration"><h4 class="function" id="toPure"><code><span class="keyword">public func </span><span class="fnname">toPure</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <a href="pure/Queue.html#type.Queue"><span class="type">PureQueue.Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Converts a mutable queue to an immutable, purely functional queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  let pureQueue = Queue.toPure&lt;Nat&gt;(queue);
}</code></pre>

<p>Runtime: O(n)
Space: O(n)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="fromPure"><code><span class="keyword">public func </span><span class="fnname">fromPure</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">pureQueue</span> : <a href="pure/Queue.html#type.Queue"><span class="type">PureQueue.Queue</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Converts an immutable, purely functional queue to a mutable queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;
import PureQueue &quot;mo:base/pure/Queue&quot;;

persistent actor {
  let pureQueue = PureQueue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  let queue = Queue.fromPure&lt;Nat&gt;(pureQueue);
}</code></pre>

<p>Runtime: O(n)
Space: O(n)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>&lt;<span class="type">T</span>&gt;() : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a new empty mutable double-ended queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.empty&lt;Text&gt;();
  assert Queue.size(queue) == 0;
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="singleton"><code><span class="keyword">public func </span><span class="fnname">singleton</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">element</span> : <span class="type">T</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a new queue with a single element.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.singleton&lt;Nat&gt;(123);
  assert Queue.size(queue) == 1;
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="clear"><code><span class="keyword">public func </span><span class="fnname">clear</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Removes all elements from the queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  Queue.clear(queue);
  assert Queue.isEmpty(queue);
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="clone"><code><span class="keyword">public func </span><span class="fnname">clone</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a deep copy of the queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let original = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  let copy = Queue.clone(original);
  Queue.clear(original);
  assert Queue.size(original) == 0;
  assert Queue.size(copy) == 3;
}</code></pre>

<p>Runtime: O(n)
Space: O(n)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Returns the number of elements in the queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Text&gt;([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;].values());
  assert Queue.size(queue) == 3;
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Bool</span></code></h4><p><p>Returns <code>true</code> if the queue contains no elements.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.empty&lt;Nat&gt;();
  assert Queue.isEmpty(queue);
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="contains"><code><span class="keyword">public func </span><span class="fnname">contains</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Checks if an element exists in the queue using the provided equality function.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.contains(queue, Nat.equal, 2);
}</code></pre>

<p>Runtime: O(n)
Space: O(1)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="peekFront"><code><span class="keyword">public func </span><span class="fnname">peekFront</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Returns the first element in the queue without removing it.
Returns null if the queue is empty.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.peekFront(queue) == ?1;
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="peekBack"><code><span class="keyword">public func </span><span class="fnname">peekBack</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Returns the last element in the queue without removing it.
Returns null if the queue is empty.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.peekBack(queue) == ?3;
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="pushFront"><code><span class="keyword">public func </span><span class="fnname">pushFront</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">element</span> : <span class="type">T</span>)</code></h4><p><p>Adds an element to the front of the queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.empty&lt;Nat&gt;();
  Queue.pushFront(queue, 1);
  assert Queue.peekFront(queue) == ?1;
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="pushBack"><code><span class="keyword">public func </span><span class="fnname">pushBack</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">element</span> : <span class="type">T</span>)</code></h4><p><p>Adds an element to the back of the queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.empty&lt;Nat&gt;();
  Queue.pushBack(queue, 1);
  assert Queue.peekBack(queue) == ?1;
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="popFront"><code><span class="keyword">public func </span><span class="fnname">popFront</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Removes and returns the first element in the queue.
Returns null if the queue is empty.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.popFront(queue) == ?1;
  assert Queue.size(queue) == 2;
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="popBack"><code><span class="keyword">public func </span><span class="fnname">popBack</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Removes and returns the last element in the queue.
Returns null if the queue is empty.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.popBack(queue) == ?3;
  assert Queue.size(queue) == 2;
}</code></pre>

<p>Runtime: O(1)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">iter</span> : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a new queue from an iterator.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Text&gt;([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;].values());
  assert Queue.size(queue) == 3;
}</code></pre>

<p>Runtime: O(n)
Space: O(n)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="values"><code><span class="keyword">public func </span><span class="fnname">values</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <a href="Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns an iterator over the elements in the queue.
Iterates from front to back.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;
persistent actor {
  let queue = Queue.fromIter&lt;Text&gt;([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;].values());
  transient let iter = Queue.values(queue);
  assert iter.next() == ?&quot;A&quot;;
  assert iter.next() == ?&quot;B&quot;;
  assert iter.next() == ?&quot;C&quot;;
  assert iter.next() == null;
}</code></pre>

<p>Runtime: O(1) for iterator creation, O(n) for full iteration
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="all"><code><span class="keyword">public func </span><span class="fnname">all</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Tests whether all elements in the queue satisfy the given predicate.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([2, 4, 6].values());
  assert Queue.all&lt;Nat&gt;(queue, func(x) { x % 2 == 0 });
}</code></pre>

<p>Runtime: O(n)
Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="any"><code><span class="keyword">public func </span><span class="fnname">any</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Tests whether any element in the queue satisfies the given predicate.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.any&lt;Nat&gt;(queue, func (x) { x &gt; 2 });
}</code></pre>

<p>Runtime: O(n)
Space: O(1)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="forEach"><code><span class="keyword">public func </span><span class="fnname">forEach</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">operation</span> : <span class="type">T</span> -&gt; ())</code></h4><p><p>Applies the given operation to all elements in the queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  var sum = 0;
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  Queue.forEach&lt;Nat&gt;(queue, func(x) { sum += x });
  assert sum == 6;
}</code></pre>

<p>Runtime: O(n)
Space: O(1)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="map"><code><span class="keyword">public func </span><span class="fnname">map</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">project</span> : <span class="type">T</span> -&gt; <span class="type">U</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">U</span>&gt;</code></h4><p><p>Creates a new queue by applying the given function to all elements.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  let doubled = Queue.map&lt;Nat, Nat&gt;(queue, func(x) { x * 2 });
  assert Queue.peekFront(doubled) == ?2;
}</code></pre>

<p>Runtime: O(n)
Space: O(n)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="filter"><code><span class="keyword">public func </span><span class="fnname">filter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">criterion</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Creates a new queue containing only elements that satisfy the given predicate.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3, 4].values());
  let evens = Queue.filter&lt;Nat&gt;(queue, func(x) { x % 2 == 0 });
  assert Queue.size(evens) == 2;
}</code></pre>

<p>Runtime: O(n)
Space: O(n)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="filterMap"><code><span class="keyword">public func </span><span class="fnname">filterMap</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">project</span> : <span class="type">T</span> -&gt; ?<span class="type">U</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">U</span>&gt;</code></h4><p><p>Creates a new queue by applying the given function to all elements
and keeping only the non-null results.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3, 4].values());
  let evenDoubled = Queue.filterMap&lt;Nat, Nat&gt;(
    queue,
    func(x) {
      if (x % 2 == 0) { ?(x * 2) } else  { null }
    }
  );
  assert Queue.size(evenDoubled) == 2;
}</code></pre>

<p>Runtime: O(n)
Space: O(n)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="equal"><code><span class="keyword">public func </span><span class="fnname">equal</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">queue1</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">queue2</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Compares two queues for equality using the provided equality function.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let queue1 = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  let queue2 = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.equal(queue1, queue2, Nat.equal);
}</code></pre>

<p>Runtime: O(n)
Space: O(1)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="toText"><code><span class="keyword">public func </span><span class="fnname">toText</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">format</span> : <span class="type">T</span> -&gt; <span class="type">Text</span>) : <span class="type">Text</span></code></h4><p><p>Converts a queue to its string representation using the provided element formatter.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let queue = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.toText(queue, Nat.toText) == &quot;Queue[1, 2, 3]&quot;;
}</code></pre>

<p>Runtime: O(n)
Space: O(n)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div><div class="declaration"><h4 class="function" id="compare"><code><span class="keyword">public func </span><span class="fnname">compare</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">queue1</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">queue2</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compareItem</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="Order.html#type.Order"><span class="type">Order.Order</span></a></code></h4><p><p>Compares two queues using the provided comparison function.
Returns #less, #equal, or #greater.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:base/Queue&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let queue1 = Queue.fromIter&lt;Nat&gt;([1, 2].values());
  let queue2 = Queue.fromIter&lt;Nat&gt;([1, 2, 3].values());
  assert Queue.compare(queue1, queue2, Nat.compare) == #less;
}</code></pre>

<p>Runtime: O(n)
Space: O(1)
<code>n</code> denotes the number of elements stored in the queue.</p>
</p></div></div></body></html>