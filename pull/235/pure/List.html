<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="../styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="../Array.html">Array</a></li></li><li><li><a href="../Blob.html">Blob</a></li></li><li><li><a href="../Bool.html">Bool</a></li></li><li><li><a href="../CertifiedData.html">CertifiedData</a></li></li><li><li><a href="../Char.html">Char</a></li></li><li><li><a href="../Cycles.html">Cycles</a></li></li><li><li><a href="../Debug.html">Debug</a></li></li><li><li><a href="../Error.html">Error</a></li></li><li><li><a href="../Float.html">Float</a></li></li><li><li><a href="../Func.html">Func</a></li></li><li><li><a href="../Int.html">Int</a></li></li><li><li><a href="../Int16.html">Int16</a></li></li><li><li><a href="../Int32.html">Int32</a></li></li><li><li><a href="../Int64.html">Int64</a></li></li><li><li><a href="../Int8.html">Int8</a></li></li><li><li><a href="../InternetComputer.html">InternetComputer</a></li></li><li><li><a href="../Iter.html">Iter</a></li></li><li><li><a href="../List.html">List</a></li></li><li><li><a href="../Map.html">Map</a></li></li><li><li><a href="../Nat.html">Nat</a></li></li><li><li><a href="../Nat16.html">Nat16</a></li></li><li><li><a href="../Nat32.html">Nat32</a></li></li><li><li><a href="../Nat64.html">Nat64</a></li></li><li><li><a href="../Nat8.html">Nat8</a></li></li><li><li><a href="../Option.html">Option</a></li></li><li><li><a href="../Order.html">Order</a></li></li><li><li><a href="../Principal.html">Principal</a></li></li><li><li><a href="../Queue.html">Queue</a></li></li><li><li><a href="../Random.html">Random</a></li></li><li><li><a href="../Region.html">Region</a></li></li><li><li><a href="../Result.html">Result</a></li></li><li><li><a href="../Runtime.html">Runtime</a></li></li><li><li><a href="../Set.html">Set</a></li></li><li><li><a href="../Stack.html">Stack</a></li></li><li><li><a href="../Text.html">Text</a></li></li><li><li><a href="../Time.html">Time</a></li></li><li><li><a href="../Timer.html">Timer</a></li></li><li><li><a href="../Tuples.html">Tuples</a></li></li><li><li><a href="../Types.html">Types</a></li></li><li><li><a href="../VarArray.html">VarArray</a></li></li><li><li><a href="../internal/BTreeHelper.html">internal/BTreeHelper</a></li></li><li><li><a href="../internal/PRNG.html">internal/PRNG</a></li></li><li><li><a href="../pure/List.html">pure/List</a></li></li><li><li><a href="../pure/Map.html">pure/Map</a></li></li><li><li><a href="../pure/OldQueue.html">pure/OldQueue</a></li></li><li><li><a href="../pure/Queue.html">pure/Queue</a></li></li><li><li><a href="../pure/Set.html">pure/Set</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.List">List</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#isEmpty">isEmpty</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#contains">contains</a></li></li><li><li><a href="#get">get</a></li></li><li><li><a href="#pushFront">pushFront</a></li></li><li><li><a href="#last">last</a></li></li><li><li><a href="#popFront">popFront</a></li></li><li><li><a href="#reverse">reverse</a></li></li><li><li><a href="#forEach">forEach</a></li></li><li><li><a href="#map">map</a></li></li><li><li><a href="#filter">filter</a></li></li><li><li><a href="#filterMap">filterMap</a></li></li><li><li><a href="#mapResult">mapResult</a></li></li><li><li><a href="#partition">partition</a></li></li><li><li><a href="#concat">concat</a></li></li><li><li><a href="#join">join</a></li></li><li><li><a href="#flatten">flatten</a></li></li><li><li><a href="#take">take</a></li></li><li><li><a href="#drop">drop</a></li></li><li><li><a href="#foldLeft">foldLeft</a></li></li><li><li><a href="#foldRight">foldRight</a></li></li><li><li><a href="#find">find</a></li></li><li><li><a href="#all">all</a></li></li><li><li><a href="#any">any</a></li></li><li><li><a href="#merge">merge</a></li></li><li><li><a href="#equal">equal</a></li></li><li><li><a href="#compare">compare</a></li></li><li><li><a href="#tabulate">tabulate</a></li></li><li><li><a href="#singleton">singleton</a></li></li><li><li><a href="#repeat">repeat</a></li></li><li><li><a href="#zip">zip</a></li></li><li><li><a href="#zipWith">zipWith</a></li></li><li><li><a href="#split">split</a></li></li><li><li><a href="#chunks">chunks</a></li></li><li><li><a href="#values">values</a></li></li><li><li><a href="#fromArray">fromArray</a></li></li><li><li><a href="#fromVarArray">fromVarArray</a></li></li><li><li><a href="#toArray">toArray</a></li></li><li><li><a href="#toVarArray">toVarArray</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#toText">toText</a></li></li></ul></nav><div class="documentation"><h1>pure/List</h1><p>Purely-functional, singly-linked lists.
A list of type <code>List&lt;T&gt;</code> is either <code>null</code> or an optional pair of a value of type <code>T</code> and a tail, itself of type <code>List&lt;T&gt;</code>.</p>
<p>To use this library, import it using:</p>
<pre><code>motoko name=import
import List &quot;mo:base/pure/List&quot;;</code></pre><div class="declaration"><h4 class="type-declaration" id="type.List"><span class="keyword">type </span><span class="type">List</span>&lt;<span class="type">T</span>&gt; = <a href="../Types.html#Pure.type.List"><span class="type">Types.Pure.List</span></a>&lt;<span class="type">T</span>&gt;</h4><p></p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>&lt;<span class="type">T</span>&gt;() : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create an empty list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  assert List.empty&lt;Nat&gt;() == null;
}</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Bool</span></code></h4><p><p>Check whether a list is empty and return true if the list is empty.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  assert List.isEmpty(null);
  assert not List.isEmpty(?(1, null));
}</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Return the length of the list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, null));
  assert List.size(list) == 2;
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="contains"><code><span class="keyword">public func </span><span class="fnname">contains</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equal</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">item</span> : <span class="type">T</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Check whether the list contains a given value. Uses the provided equality function to compare values.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert List.contains(list, Nat.equal, 2);
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>equal</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="get"><code><span class="keyword">public func </span><span class="fnname">get</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">n</span> : <span class="type">Nat</span>) : ?<span class="type">T</span></code></h4><p><p>Access any item in a list, zero-based.</p>
<p>NOTE: Indexing into a list is a linear operation, and usually an
indication that a list might not be the best data structure
to use.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, null));
  assert List.get(list, 1) == ?1;
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="pushFront"><code><span class="keyword">public func </span><span class="fnname">pushFront</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">item</span> : <span class="type">T</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Add <code>item</code> to the head of <code>list</code>, and return the new list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  assert List.pushFront(null, 0) == ?(0, null);
}</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="last"><code><span class="keyword">public func </span><span class="fnname">last</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Return the last element of the list, if present.
Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, null));
  assert List.last(list) == ?1;
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="popFront"><code><span class="keyword">public func </span><span class="fnname">popFront</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : (?<span class="type">T</span>, <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Remove the head of the list, returning the optioned head and the tail of the list in a pair.
Returns <code>(null, null)</code> if the list is empty.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, null));
  assert List.popFront(list) == (?0, ?(1, null));
}</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="reverse"><code><span class="keyword">public func </span><span class="fnname">reverse</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Reverses the list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, null)));
  assert List.reverse(list) == ?(2, ?(1, ?(0, null)));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="forEach"><code><span class="keyword">public func </span><span class="fnname">forEach</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; ())</code></h4><p><p>Call the given function for its side effect, with each list element in turn.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, null)));
  var sum = 0;
  List.forEach&lt;Nat&gt;(list, func n = sum += n);
  assert sum == 3;
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="map"><code><span class="keyword">public func </span><span class="fnname">map</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T1</span>&gt;, <span class="parameter">f</span> : <span class="type">T1</span> -&gt; <span class="type">T2</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T2</span>&gt;</code></h4><p><p>Call the given function <code>f</code> on each list element and collect the results
in a new list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, null)));
  assert List.map(list, Nat.toText) == ?(&quot;0&quot;, ?(&quot;1&quot;, ?(&quot;2&quot;, null)));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)
*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="filter"><code><span class="keyword">public func </span><span class="fnname">filter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a new list with only those elements of the original list for which
the given function (often called the <em>predicate</em>) returns true.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, null)));
  assert List.filter&lt;Nat&gt;(list, func n = n != 1) == ?(0, ?(2, null));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="filterMap"><code><span class="keyword">public func </span><span class="fnname">filterMap</span>&lt;<span class="type">T</span>, <span class="type">R</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; ?<span class="type">R</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">R</span>&gt;</code></h4><p><p>Call the given function on each list element, and collect the non-null results
in a new list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert List.filterMap&lt;Nat, Nat&gt;(
    list,
    func n = if (n &gt; 1) ?(n * 2) else null
  ) == ?(4, ?(6, null));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="mapResult"><code><span class="keyword">public func </span><span class="fnname">mapResult</span>&lt;<span class="type">T</span>, <span class="type">R</span>, <span class="type">E</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <a href="../Result.html#type.Result"><span class="type">Result.Result</span></a>&lt;<span class="type">R</span>, <span class="type">E</span>&gt;) : <a href="../Result.html#type.Result"><span class="type">Result.Result</span></a>&lt;<a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">R</span>&gt;, <span class="type">E</span>&gt;</code></h4><p><p>Maps a <code>Result</code>-returning function <code>f</code> over a <code>List</code> and returns either
the first error or a list of successful values.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert List.mapResult&lt;Nat, Nat, Text&gt;(
    list,
    func n = if (n &gt; 0) #ok(n * 2) else #err &quot;Some element is zero&quot;
  ) == #ok(?(2, ?(4, ?(6, null))));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="partition"><code><span class="keyword">public func </span><span class="fnname">partition</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : (<a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Create two new lists from the results of a given function (<code>f</code>).
The first list only includes the elements for which the given
function <code>f</code> returns true and the second list only includes
the elements for which the function returns false.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, null)));
  assert List.partition&lt;Nat&gt;(list, func n = n != 1) == (?(0, ?(2, null)), ?(1, null));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="concat"><code><span class="keyword">public func </span><span class="fnname">concat</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list1</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">list2</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Append the elements from one list to another list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list1 = ?(0, ?(1, ?(2, null)));
  let list2 = ?(3, ?(4, ?(5, null)));
  assert List.concat(list1, list2) == ?(0, ?(1, ?(2, ?(3, ?(4, ?(5, null))))));
}</code></pre>

<p>Runtime: O(size(l))</p>
<p>Space: O(size(l))</p>
</p></div><div class="declaration"><h4 class="function" id="join"><code><span class="keyword">public func </span><span class="fnname">join</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">iter</span> : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Flatten, or repatedly concatenate, an iterator of lists as a list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Iter &quot;mo:base/Iter&quot;;

persistent actor {
  let lists = [ ?(0, ?(1, ?(2, null))),
                ?(3, ?(4, ?(5, null))) ];
  assert List.join(lists |&gt; Iter.fromArray(_)) == ?(0, ?(1, ?(2, ?(3, ?(4, ?(5, null))))));
}</code></pre>

<p>Runtime: O(size*size)</p>
<p>Space: O(size*size)</p>
</p></div><div class="declaration"><h4 class="function" id="flatten"><code><span class="keyword">public func </span><span class="fnname">flatten</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Flatten, or repatedly concatenate, a list of lists as a list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let lists = ?(?(0, ?(1, ?(2, null))),
               ?(?(3, ?(4, ?(5, null))),
                 null));
  assert List.flatten(lists) == ?(0, ?(1, ?(2, ?(3, ?(4, ?(5, null))))));
}</code></pre>

<p>Runtime: O(size*size)</p>
<p>Space: O(size*size)</p>
</p></div><div class="declaration"><h4 class="function" id="take"><code><span class="keyword">public func </span><span class="fnname">take</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">n</span> : <span class="type">Nat</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns the first <code>n</code> elements of the given list.
If the given list has fewer than <code>n</code> elements, this function returns
a copy of the full input list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, null)));
  assert List.take(list, 2) == ?(0, ?(1, null));
}</code></pre>

<p>Runtime: O(n)</p>
<p>Space: O(n)</p>
</p></div><div class="declaration"><h4 class="function" id="drop"><code><span class="keyword">public func </span><span class="fnname">drop</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">n</span> : <span class="type">Nat</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Drop the first <code>n</code> elements from the given list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, null)));
  assert List.drop(list, 2) == ?(2, null);
}</code></pre>

<p>Runtime: O(n)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="foldLeft"><code><span class="keyword">public func </span><span class="fnname">foldLeft</span>&lt;<span class="type">T</span>, <span class="type">A</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">A</span>, <span class="type">T</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Collapses the elements in <code>list</code> into a single value by starting with <code>base</code>
and progessively combining elements into <code>base</code> with <code>combine</code>. Iteration runs
left to right.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert List.foldLeft&lt;Nat, Text&gt;(
    list,
    &quot;&quot;,
    func (acc, x) = acc # Nat.toText(x)
  ) == &quot;123&quot;;
}</code></pre>

<p>Runtime: O(size(list))</p>
<p>Space: O(1) heap, O(1) stack</p>
<p>*Runtime and space assumes that <code>combine</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="foldRight"><code><span class="keyword">public func </span><span class="fnname">foldRight</span>&lt;<span class="type">T</span>, <span class="type">A</span>&gt;(<br/>  <span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">T</span>, <span class="type">A</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Collapses the elements in <code>buffer</code> into a single value by starting with <code>base</code>
and progessively combining elements into <code>base</code> with <code>combine</code>. Iteration runs
right to left.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert List.foldRight&lt;Nat, Text&gt;(
    list,
    &quot;&quot;,
    func (x, acc) = Nat.toText(x) # acc
  ) == &quot;123&quot;;
}</code></pre>

<p>Runtime: O(size(list))</p>
<p>Space: O(1) heap, O(size(list)) stack</p>
<p>*Runtime and space assumes that <code>combine</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="find"><code><span class="keyword">public func </span><span class="fnname">find</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : ?<span class="type">T</span></code></h4><p><p>Return the first element for which the given predicate <code>f</code> is true,
if such an element exists.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert List.find&lt;Nat&gt;(list, func n = n &gt; 1) == ?2;
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="all"><code><span class="keyword">public func </span><span class="fnname">all</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Return true if the given predicate <code>f</code> is true for all list
elements.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert not List.all&lt;Nat&gt;(list, func n = n &gt; 1);
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="any"><code><span class="keyword">public func </span><span class="fnname">any</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Return true if there exists a list element for which
the given predicate <code>f</code> is true.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert List.any&lt;Nat&gt;(list, func n = n &gt; 1);
}</code></pre>

<p>Runtime: O(size(list))</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="merge"><code><span class="keyword">public func </span><span class="fnname">merge</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list1</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">list2</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Merge two ordered lists into a single ordered list.
This function requires both list to be ordered as specified
by the given relation <code>compare</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list1 = ?(1, ?(2, ?(4, null)));
  let list2 = ?(2, ?(4, ?(6, null)));
  assert List.merge(list1, list2, Nat.compare) == ?(1, ?(2, ?(2, ?(4, ?(4, ?(6, null))))));
}</code></pre>

<p>Runtime: O(size(l1) + size(l2))</p>
<p>Space: O(size(l1) + size(l2))</p>
<p>*Runtime and space assumes that <code>lessThanOrEqual</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="equal"><code><span class="keyword">public func </span><span class="fnname">equal</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list1</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">list2</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equalItem</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Check if two lists are equal using the given equality function to compare elements.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list1 = ?(1, ?(2, null));
  let list2 = ?(1, ?(2, null));
  assert List.equal(list1, list2, Nat.equal);
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that <code>equalItem</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="compare"><code><span class="keyword">public func </span><span class="fnname">compare</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">list1</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">list2</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compareItem</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="../Order.html#type.Order"><span class="type">Order.Order</span></a></code></h4><p><p>Compare two lists using lexicographic ordering specified by argument function <code>compareItem</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list1 = ?(1, ?(2, null));
  let list2 = ?(3, ?(4, null));
  assert List.compare(list1, list2, Nat.compare) == #less;
}</code></pre>

<p>Runtime: O(size(l1))</p>
<p>Space: O(1)</p>
<p>*Runtime and space assumes that argument <code>compare</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="tabulate"><code><span class="keyword">public func </span><span class="fnname">tabulate</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">n</span> : <span class="type">Nat</span>, <span class="parameter">f</span> : <span class="type">Nat</span> -&gt; <span class="type">T</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Generate a list based on a length and a function that maps from
a list index to a list element.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = List.tabulate&lt;Nat&gt;(3, func n = n * 2);
  assert list == ?(0, ?(2, ?(4, null)));
}</code></pre>

<p>Runtime: O(n)</p>
<p>Space: O(n)</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="singleton"><code><span class="keyword">public func </span><span class="fnname">singleton</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">item</span> : <span class="type">T</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a list with exactly one element.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  assert List.singleton(0) == ?(0, null);
}</code></pre>

<p>Runtime: O(1)</p>
<p>Space: O(1)</p>
</p></div><div class="declaration"><h4 class="function" id="repeat"><code><span class="keyword">public func </span><span class="fnname">repeat</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">item</span> : <span class="type">T</span>, <span class="parameter">n</span> : <span class="type">Nat</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a list of the given length with the same value in each position.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = List.repeat('a', 3);
  assert list == ?('a', ?('a', ?('a', null)));
}</code></pre>

<p>Runtime: O(n)</p>
<p>Space: O(n)</p>
</p></div><div class="declaration"><h4 class="function" id="zip"><code><span class="keyword">public func </span><span class="fnname">zip</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;(<span class="parameter">list1</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">list2</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">U</span>&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;(<span class="type">T</span>, <span class="type">U</span>)&gt;</code></h4><p><p>Create a list of pairs from a pair of lists.</p>
<p>If the given lists have different lengths, then the created list will have a
length equal to the length of the smaller list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list1 = ?(0, ?(1, ?(2, null)));
  let list2 = ?(&quot;0&quot;, ?(&quot;1&quot;, null));
  assert List.zip(list1, list2) == ?((0, &quot;0&quot;), ?((1, &quot;1&quot;), null));
}</code></pre>

<p>Runtime: O(min(size(xs), size(ys)))</p>
<p>Space: O(min(size(xs), size(ys)))</p>
</p></div><div class="declaration"><h4 class="function" id="zipWith"><code><span class="keyword">public func </span><span class="fnname">zipWith</span>&lt;<span class="type">T</span>, <span class="type">U</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">list1</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">list2</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">U</span>&gt;, <br/>  <span class="parameter">f</span> : (<span class="type">T</span>, <span class="type">U</span>) -&gt; <span class="type">V</span><br/>) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">V</span>&gt;</code></h4><p><p>Create a list in which elements are created by applying function <code>f</code> to each pair <code>(x, y)</code> of elements
occuring at the same position in list <code>xs</code> and list <code>ys</code>.</p>
<p>If the given lists have different lengths, then the created list will have a
length equal to the length of the smaller list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Char &quot;mo:base/Char&quot;;

persistent actor {
  let list1 = ?(0, ?(1, ?(2, null)));
  let list2 = ?('a', ?('b', null));
  assert List.zipWith&lt;Nat, Char, Text&gt;(
    list1,
    list2,
    func (n, c) = Nat.toText(n) # Char.toText(c)
  ) == ?(&quot;0a&quot;, ?(&quot;1b&quot;, null));
}</code></pre>

<p>Runtime: O(min(size(xs), size(ys)))</p>
<p>Space: O(min(size(xs), size(ys)))</p>
<p>*Runtime and space assumes that <code>f</code> runs in O(1) time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="split"><code><span class="keyword">public func </span><span class="fnname">split</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">n</span> : <span class="type">Nat</span>) : (<a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Split the given list at the given zero-based index.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, null)));
  assert List.split(list, 2) == (?(0, ?(1, null)), ?(2, null));
}</code></pre>

<p>Runtime: O(n)</p>
<p>Space: O(n)</p>
</p></div><div class="declaration"><h4 class="function" id="chunks"><code><span class="keyword">public func </span><span class="fnname">chunks</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">n</span> : <span class="type">Nat</span>) : <a href="#type.List"><span class="type">List</span></a>&lt;<a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;&gt;</code></h4><p><p>Split the given list into chunks of length <code>n</code>.
The last chunk will be shorter if the length of the given list
does not divide by <code>n</code> evenly. Traps if <code>n</code> = 0.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = ?(0, ?(1, ?(2, ?(3, ?(4, null)))));
  assert List.chunks(list, 2) == ?(?(0, ?(1, null)), ?(?(2, ?(3, null)), ?(?(4, null), null)));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="values"><code><span class="keyword">public func </span><span class="fnname">values</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns an iterator to the elements in the list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list = List.fromArray([3, 1, 4]);
  var text = &quot;&quot;;
  for (item in List.values(list)) {
    text #= Nat.toText(item);
  };
  assert text == &quot;314&quot;;
}</code></pre></p></div><div class="declaration"><h4 class="function" id="fromArray"><code><span class="keyword">public func </span><span class="fnname">fromArray</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">array</span> : [<span class="type">T</span>]) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Convert an array into a list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = List.fromArray([0, 1, 2, 3, 4]);
  assert list == ?(0, ?(1, ?(2, ?(3, ?(4, null)))));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="fromVarArray"><code><span class="keyword">public func </span><span class="fnname">fromVarArray</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">array</span> : [<span class="keyword">var </span><span class="type">T</span>]) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Convert a mutable array into a list.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = List.fromVarArray([var 0, 1, 2, 3, 4]);
  assert list == ?(0, ?(1, ?(2, ?(3, ?(4, null)))));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="toArray"><code><span class="keyword">public func </span><span class="fnname">toArray</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : [<span class="type">T</span>]</code></h4><p><p>Create an array from a list.
Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Array &quot;mo:base/Array&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let array = List.toArray(?(0, ?(1, ?(2, ?(3, ?(4, null))))));
  assert Array.equal(array, [0, 1, 2, 3, 4], Nat.equal);
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="toVarArray"><code><span class="keyword">public func </span><span class="fnname">toVarArray</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;) : [<span class="keyword">var </span><span class="type">T</span>]</code></h4><p><p>Create a mutable array from a list.
Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Array &quot;mo:base/Array&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let array = List.toVarArray&lt;Nat&gt;(?(0, ?(1, ?(2, ?(3, ?(4, null))))));
  assert Array.equal(Array.fromVarArray(array), [0, 1, 2, 3, 4], Nat.equal);
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">iter</span> : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Turn an iterator into a list, consuming it.
Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;

persistent actor {
  let list = List.fromIter([0, 1, 2, 3, 4].vals());
  assert list == ?(0, ?(1, ?(2, ?(3, ?(4, null)))));
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div><div class="declaration"><h4 class="function" id="toText"><code><span class="keyword">public func </span><span class="fnname">toText</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">list</span> : <a href="#type.List"><span class="type">List</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">Text</span>) : <span class="type">Text</span></code></h4><p><p>Convert a list to a text representation using the provided function to convert each element to text.
The resulting text will be in the format &quot;[element1, element2, ...]&quot;.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import List &quot;mo:base/pure/List&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let list = ?(1, ?(2, ?(3, null)));
  assert List.toText(list, Nat.toText) == &quot;[1, 2, 3]&quot;;
}</code></pre>

<p>Runtime: O(size)</p>
<p>Space: O(size)</p>
</p></div></div></body></html>