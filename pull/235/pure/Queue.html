<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="../styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="../Array.html">Array</a></li></li><li><li><a href="../Blob.html">Blob</a></li></li><li><li><a href="../Bool.html">Bool</a></li></li><li><li><a href="../CertifiedData.html">CertifiedData</a></li></li><li><li><a href="../Char.html">Char</a></li></li><li><li><a href="../Cycles.html">Cycles</a></li></li><li><li><a href="../Debug.html">Debug</a></li></li><li><li><a href="../Error.html">Error</a></li></li><li><li><a href="../Float.html">Float</a></li></li><li><li><a href="../Func.html">Func</a></li></li><li><li><a href="../Int.html">Int</a></li></li><li><li><a href="../Int16.html">Int16</a></li></li><li><li><a href="../Int32.html">Int32</a></li></li><li><li><a href="../Int64.html">Int64</a></li></li><li><li><a href="../Int8.html">Int8</a></li></li><li><li><a href="../InternetComputer.html">InternetComputer</a></li></li><li><li><a href="../Iter.html">Iter</a></li></li><li><li><a href="../List.html">List</a></li></li><li><li><a href="../Map.html">Map</a></li></li><li><li><a href="../Nat.html">Nat</a></li></li><li><li><a href="../Nat16.html">Nat16</a></li></li><li><li><a href="../Nat32.html">Nat32</a></li></li><li><li><a href="../Nat64.html">Nat64</a></li></li><li><li><a href="../Nat8.html">Nat8</a></li></li><li><li><a href="../Option.html">Option</a></li></li><li><li><a href="../Order.html">Order</a></li></li><li><li><a href="../Principal.html">Principal</a></li></li><li><li><a href="../Queue.html">Queue</a></li></li><li><li><a href="../Random.html">Random</a></li></li><li><li><a href="../Region.html">Region</a></li></li><li><li><a href="../Result.html">Result</a></li></li><li><li><a href="../Runtime.html">Runtime</a></li></li><li><li><a href="../Set.html">Set</a></li></li><li><li><a href="../Stack.html">Stack</a></li></li><li><li><a href="../Text.html">Text</a></li></li><li><li><a href="../Time.html">Time</a></li></li><li><li><a href="../Timer.html">Timer</a></li></li><li><li><a href="../Tuples.html">Tuples</a></li></li><li><li><a href="../Types.html">Types</a></li></li><li><li><a href="../VarArray.html">VarArray</a></li></li><li><li><a href="../internal/BTreeHelper.html">internal/BTreeHelper</a></li></li><li><li><a href="../internal/PRNG.html">internal/PRNG</a></li></li><li><li><a href="../pure/List.html">pure/List</a></li></li><li><li><a href="../pure/Map.html">pure/Map</a></li></li><li><li><a href="../pure/OldQueue.html">pure/OldQueue</a></li></li><li><li><a href="../pure/Queue.html">pure/Queue</a></li></li><li><li><a href="../pure/Set.html">pure/Set</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Queue">Queue</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#isEmpty">isEmpty</a></li></li><li><li><a href="#singleton">singleton</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#contains">contains</a></li></li><li><li><a href="#peekFront">peekFront</a></li></li><li><li><a href="#peekBack">peekBack</a></li></li><li><li><a href="#pushFront">pushFront</a></li></li><li><li><a href="#pushBack">pushBack</a></li></li><li><li><a href="#popFront">popFront</a></li></li><li><li><a href="#debugState">debugState</a></li></li><li><li><a href="#popBack">popBack</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#values">values</a></li></li><li><li><a href="#valuesRev">valuesRev</a></li></li><li><li><a href="#equal">equal</a></li></li><li><li><a href="#compare">compare</a></li></li><li><li><a href="#all">all</a></li></li><li><li><a href="#any">any</a></li></li><li><li><a href="#forEach">forEach</a></li></li><li><li><a href="#map">map</a></li></li><li><li><a href="#filter">filter</a></li></li><li><li><a href="#filterMap">filterMap</a></li></li><li><li><a href="#toText">toText</a></li></li><li><li><a href="#reverse">reverse</a></li></li><li><li><a href="#idlesInvariant">idlesInvariant</a></li></li></ul></nav><div class="documentation"><h1>pure/Queue</h1><p>Double-ended queue of a generic element type <code>T</code>.</p>
<p>The interface is purely functional, not imperative, and queues are immutable values.
In particular, Queue operations such as push and pop do not update their input queue but, instead, return the
value of the modified Queue, alongside any other data.
The input queue is left unchanged.</p>
<p>Examples of use-cases:</p>
<ul><li>Queue (FIFO) by using <code>pushBack()</code> and <code>popFront()</code>.</li><li>Stack (LIFO) by using <code>pushFront()</code> and <code>popFront()</code>.</li><li>Deque (double-ended queue) by using any combination of push/pop operations on either end.</li></ul>

<p>A Queue is internally implemented as a real-time double-ended queue based on the paper
&quot;Real-Time Double-Ended Queue Verified (Proof Pearl)&quot;. The implementation maintains
worst-case constant time <code>O(1)</code> for push/pop operations through gradual rebalancing steps.</p>
<p>Construction: Create a new queue with the <code>empty&lt;T&gt;()</code> function.</p>
<p>Note that some operations that traverse the elements of the queue (e.g. <code>forEach</code>, <code>values</code>) preserve the order of the elements,
whereas others (e.g. <code>map</code>, <code>contains</code>, <code>any</code>) do NOT guarantee that the elements are visited in any order.
The order is undefined to avoid allocations, making these operations more efficient.</p>
<div class="declaration"><h4 class="type-declaration" id="type.Queue"><span class="keyword">type </span><span class="type">Queue</span>&lt;<span class="type">T</span>&gt; = {#empty; #one : <span class="type">T</span>; #two : (<span class="type">T</span>, <span class="type">T</span>); #three : (<span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>); #idles : (<a href="#type.Idle"><span class="type">Idle</span></a>&lt;<span class="type">T</span>&gt;, <a href="#type.Idle"><span class="type">Idle</span></a>&lt;<span class="type">T</span>&gt;); #rebal : <a href="#type.States"><span class="type">States</span></a>&lt;<span class="type">T</span>&gt;}</h4><p><p>The real-time queue data structure can be in one of the following states:</p>
<ul><li><code>#empty</code>: the queue is empty</li><li><code>#one</code>: the queue contains a single element</li><li><code>#two</code>: the queue contains two elements</li><li><code>#three</code>: the queue contains three elements</li><li><code>#idles</code>: the queue is in the idle state, where <code>l</code> and <code>r</code> are non-empty stacks of elements fulfilling the size invariant</li><li><code>#rebal</code>: the queue is in the rebalancing state</li></ul></p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>&lt;<span class="type">T</span>&gt;() : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a new empty queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

Queue.empty&lt;Nat&gt;()</code></pre>

<p>Runtime: <code>O(1)</code>.</p>
<p>Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Bool</span></code></h4><p><p>Determine whether a queue is empty.
Returns true if <code>queue</code> is empty, otherwise <code>false</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.empty&lt;Nat&gt;();
Queue.isEmpty(queue) // =&gt; true</code></pre>

<p>Runtime: <code>O(1)</code>.</p>
<p>Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="singleton"><code><span class="keyword">public func </span><span class="fnname">singleton</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">element</span> : <span class="type">T</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a new queue comprising a single element.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

Queue.singleton&lt;Nat&gt;(25)</code></pre>

<p>Runtime: <code>O(1)</code>.</p>
<p>Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Determine the number of elements contained in a queue.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import {singleton; size} &quot;mo:new-base/Queue&quot;;

let queue = singleton&lt;Nat&gt;(42);
size(queue) // =&gt; 1</code></pre>

<p>Runtime: <code>O(1)</code>.</p>
<p>Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="contains"><code><span class="keyword">public func </span><span class="fnname">contains</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">eq</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">item</span> : <span class="type">T</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Test if a queue contains a given value.
Returns true if the queue contains the item, otherwise false.
Note that this operation traverses the elements in arbitrary order.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;
import Nat &quot;mo:new-base/Nat&quot;;

let queue = Queue.pushBack(Queue.pushBack(Queue.empty&lt;Nat&gt;(), 1), 2);
Queue.contains(queue, Nat.equal, 1) // =&gt; true</code></pre>

<p>Note that the order in which the elements from the <code>queue</code> are checked is undefined and may vary.</p>
<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="peekFront"><code><span class="keyword">public func </span><span class="fnname">peekFront</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Inspect the optional element on the front end of a queue.
Returns <code>null</code> if <code>queue</code> is empty. Otherwise, the front element of <code>queue</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.pushFront(Queue.pushFront(Queue.empty&lt;Nat&gt;(), 2), 1);
Queue.peekFront(queue) // =&gt; ?1</code></pre>

<p>Runtime: <code>O(1)</code>.</p>
<p>Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="peekBack"><code><span class="keyword">public func </span><span class="fnname">peekBack</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Inspect the optional element on the back end of a queue.
Returns <code>null</code> if <code>queue</code> is empty. Otherwise, the back element of <code>queue</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.pushBack(Queue.pushBack(Queue.empty&lt;Nat&gt;(), 1), 2);
Queue.peekBack(queue) // =&gt; ?2</code></pre>

<p>Runtime: <code>O(1)</code>.</p>
<p>Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="pushFront"><code><span class="keyword">public func </span><span class="fnname">pushFront</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">element</span> : <span class="type">T</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Insert a new element on the front end of a queue.
Returns the new queue with <code>element</code> in the front followed by the elements of <code>queue</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

Queue.pushFront(Queue.pushFront(Queue.empty&lt;Nat&gt;(), 2), 1) // queue with elements [1, 2]</code></pre>

<p>Runtime: <code>O(1)</code> worst-case!</p>
<p>Space: <code>O(1)</code> worst-case!</p>
</p></div><div class="declaration"><h4 class="function" id="pushBack"><code><span class="keyword">public func </span><span class="fnname">pushBack</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">element</span> : <span class="type">T</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Insert a new element on the back end of a queue.
Returns the new queue with all the elements of <code>queue</code>, followed by <code>element</code> on the back.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

Queue.pushBack(Queue.pushBack(Queue.empty&lt;Nat&gt;(), 1), 2) // queue with elements [1, 2]</code></pre>

<p>Runtime: <code>O(1)</code> worst-case!</p>
<p>Space: <code>O(1)</code> worst-case!</p>
</p></div><div class="declaration"><h4 class="function" id="popFront"><code><span class="keyword">public func </span><span class="fnname">popFront</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : ?(<span class="type">T</span>, <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Remove the element on the front end of a queue.
Returns <code>null</code> if <code>queue</code> is empty. Otherwise, it returns a pair of
the first element and a new queue that contains all the remaining elements of <code>queue</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;
import Debug &quot;mo:new-base/Debug&quot;;

let initial = Queue.pushFront(Queue.pushFront(Queue.empty&lt;Nat&gt;(), 2), 1); // initial queue with elements [1, 2]
Queue.popFront(initial) // =&gt; ?(1, [2])</code></pre>

<p>Runtime: <code>O(1)</code> worst-case!</p>
<p>Space: <code>O(1)</code> worst-case!</p>
</p></div><div class="declaration"><h4 class="function" id="debugState"><code><span class="keyword">public func </span><span class="fnname">debugState</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">q</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : {#empty; #one; #two; #three; #idles; #rebal}</code></h4><p></p></div><div class="declaration"><h4 class="function" id="popBack"><code><span class="keyword">public func </span><span class="fnname">popBack</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : ?(<a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="type">T</span>)</code></h4><p><p>Remove the element on the back end of a queue.
Returns <code>null</code> if <code>queue</code> is empty. Otherwise, it returns a pair of
a new queue that contains the remaining elements of <code>queue</code>
and, as the second pair item, the removed back element.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;
import Debug &quot;mo:new-base/Debug&quot;;

let initial = Queue.pushBack(Queue.pushBack(Queue.empty&lt;Nat&gt;(), 1), 2); // initial queue with elements [1, 2]
Queue.popBack(initial) // =&gt; ?(2, [1])</code></pre>

<p>Runtime: <code>O(1)</code> worst-case!</p>
<p>Space: <code>O(1)</code> worst-case!</p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">iter</span> : <a href="#type.Iter"><span class="type">Iter</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Turn an iterator into a queue, consuming it.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

Queue.fromIter([1, 2, 3].vals()) // queue with elements [1, 2, 3], 1 at the front, 3 at the back</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="values"><code><span class="keyword">public func </span><span class="fnname">values</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create an iterator over the elements in the queue. The order of the elements is from front to back.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.fromIter([1, 2, 3].vals());
let iter = Queue.values(queue);
Array.fromIter(iter) // =&gt; [1, 2, 3]</code></pre>

<p>Runtime: <code>O(1)</code> to create the iterator and for each <code>next()</code> call.</p>
<p>Space: <code>O(1)</code> to create the iterator and for each <code>next()</code> call.</p>
</p></div><div class="declaration"><h4 class="function" id="valuesRev"><code><span class="keyword">public func </span><span class="fnname">valuesRev</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <a href="../Iter.html#type.Iter"><span class="type">Iter.Iter</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create an iterator over the elements in the queue. The order of the elements is from back to front.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.fromIter([1, 2, 3].vals());
let iter = Queue.valuesRev(queue);
Array.fromIter(iter) // =&gt; [3, 2, 1]</code></pre>

<p>Runtime: <code>O(1)</code> to create the iterator and for each <code>next()</code> call.</p>
<p>Space: <code>O(1)</code> to create the iterator and for each <code>next()</code> call.</p>
</p></div><div class="declaration"><h4 class="function" id="equal"><code><span class="keyword">public func </span><span class="fnname">equal</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">queue1</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">queue2</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">equality</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Compare two queues for equality using a provided equality function to compare their elements.
Two queues are considered equal if they contain the same elements in the same order.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;
import Nat &quot;mo:new-base/Nat&quot;;

let queue1 = Queue.fromIter([1, 2, 3].vals());
let queue2 = Queue.fromIter([1, 2, 3].vals());
Queue.equal(queue1, queue2, Nat.equal) // =&gt; true</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="compare"><code><span class="keyword">public func </span><span class="fnname">compare</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">queue1</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">queue2</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">comparison</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="../Types.html#type.Order"><span class="type">Types.Order</span></a><br/>) : <a href="../Types.html#type.Order"><span class="type">Types.Order</span></a></code></h4><p><p>Compare two queues lexicographically using a provided comparison function to compare their elements.
Returns <code>#less</code> if <code>queue1</code> is lexicographically less than <code>queue2</code>, <code>#equal</code> if they are equal, and <code>#greater</code> otherwise.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;
import Nat &quot;mo:new-base/Nat&quot;;

let queue1 = Queue.fromIter([1, 2, 3].vals());
let queue2 = Queue.fromIter([1, 2, 4].vals());
Queue.compare(queue1, queue2, Nat.compare) // =&gt; #less</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
</p></div><div class="declaration"><h4 class="function" id="all"><code><span class="keyword">public func </span><span class="fnname">all</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Return true if the given predicate is true for all queue elements.
Note that this operation traverses the elements in arbitrary order.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.fromIter([2, 4, 6].vals());
Queue.all(queue, func n = n % 2 == 0) // =&gt; true</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that predicate runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="any"><code><span class="keyword">public func </span><span class="fnname">any</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Return true if the given predicate is true for any queue element.
Note that this operation traverses the elements in arbitrary order.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.fromIter([1, 2, 3].vals());
Queue.any(queue, func n = n &gt; 2) // =&gt; true</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(1)</code></p>
<p>*Runtime and space assumes that predicate runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="forEach"><code><span class="keyword">public func </span><span class="fnname">forEach</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; ())</code></h4><p><p>Call the given function for its side effect on each queue element in order: from front to back.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

var sum = 0;
let queue = Queue.fromIter([1, 2, 3].vals());
Queue.forEach(queue, func n = sum += n);
sum // =&gt; 6</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that f runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="map"><code><span class="keyword">public func </span><span class="fnname">map</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T1</span>&gt;, <span class="parameter">f</span> : <span class="type">T1</span> -&gt; <span class="type">T2</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T2</span>&gt;</code></h4><p><p>Create a new queue by applying the given function to each element of the original queue.
Note that this operation traverses the elements in arbitrary order.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;
import Nat &quot;mo:new-base/Nat&quot;;

let queue = Queue.fromIter([1, 2, 3].vals());
let mapped = Queue.map(queue, func n = n * 2) // queue with elements [2, 4, 6]</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that f runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="filter"><code><span class="keyword">public func </span><span class="fnname">filter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a new queue with only those elements of the original queue for which
the given predicate returns true.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.fromIter([1, 2, 3, 4].vals());
let filtered = Queue.filter(queue, func n = n % 2 == 0) // queue with elements [2, 4]</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that predicate runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="filterMap"><code><span class="keyword">public func </span><span class="fnname">filterMap</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; ?<span class="type">U</span>) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">U</span>&gt;</code></h4><p><p>Create a new queue by applying the given function to each element of the original queue
and collecting the results for which the function returns a non-null value.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.fromIter([1, 2, 3, 4].vals());
let filtered = Queue.filterMap(queue, func n = if n % 2 == 0 then ?n else null) // queue with elements [2, 4]</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that f runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="toText"><code><span class="keyword">public func </span><span class="fnname">toText</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">f</span> : <span class="type">T</span> -&gt; <span class="type">Text</span>) : <span class="type">Text</span></code></h4><p><p>Create a <code>Text</code> representation of a queue for debugging purposes.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.fromIter([1, 2, 3].vals());
Queue.toText(queue, Nat.toText) // =&gt; &quot;PureQueue[1, 2, 3]&quot;</code></pre>

<p>Runtime: <code>O(size)</code></p>
<p>Space: <code>O(size)</code></p>
<p>*Runtime and space assumes that f runs in <code>O(1)</code> time and space.</p>
</p></div><div class="declaration"><h4 class="function" id="reverse"><code><span class="keyword">public func </span><span class="fnname">reverse</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">queue</span> : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.Queue"><span class="type">Queue</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Reverse the order of elements in a queue.
This operation is cheap, it does NOT require copying the elements.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:new-base/Queue&quot;;

let queue = Queue.fromIter([1, 2, 3].vals());
Queue.toText(Queue.reverse(queue), Nat.toText) // =&gt; &quot;PureQueue[3, 2, 1]&quot;</code></pre>

<p>Runtime: <code>O(1)</code></p>
<p>Space: <code>O(1)</code></p>
</p></div><div class="declaration"><h4 class="function" id="idlesInvariant"><code><span class="keyword">public func </span><span class="fnname">idlesInvariant</span>&lt;<span class="type">T</span>&gt;() : <span class="type">Bool</span></code></h4><p></p></div></div></body></html>