<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Array.html">Array</a></li></li><li><li><a href="Blob.html">Blob</a></li></li><li><li><a href="Bool.html">Bool</a></li></li><li><li><a href="CertifiedData.html">CertifiedData</a></li></li><li><li><a href="Char.html">Char</a></li></li><li><li><a href="Cycles.html">Cycles</a></li></li><li><li><a href="Debug.html">Debug</a></li></li><li><li><a href="Error.html">Error</a></li></li><li><li><a href="Float.html">Float</a></li></li><li><li><a href="Func.html">Func</a></li></li><li><li><a href="Int.html">Int</a></li></li><li><li><a href="Int16.html">Int16</a></li></li><li><li><a href="Int32.html">Int32</a></li></li><li><li><a href="Int64.html">Int64</a></li></li><li><li><a href="Int8.html">Int8</a></li></li><li><li><a href="InternetComputer.html">InternetComputer</a></li></li><li><li><a href="Iter.html">Iter</a></li></li><li><li><a href="List.html">List</a></li></li><li><li><a href="Map.html">Map</a></li></li><li><li><a href="Nat.html">Nat</a></li></li><li><li><a href="Nat16.html">Nat16</a></li></li><li><li><a href="Nat32.html">Nat32</a></li></li><li><li><a href="Nat64.html">Nat64</a></li></li><li><li><a href="Nat8.html">Nat8</a></li></li><li><li><a href="Option.html">Option</a></li></li><li><li><a href="Order.html">Order</a></li></li><li><li><a href="Principal.html">Principal</a></li></li><li><li><a href="Queue.html">Queue</a></li></li><li><li><a href="Random.html">Random</a></li></li><li><li><a href="Region.html">Region</a></li></li><li><li><a href="Result.html">Result</a></li></li><li><li><a href="Runtime.html">Runtime</a></li></li><li><li><a href="Set.html">Set</a></li></li><li><li><a href="Stack.html">Stack</a></li></li><li><li><a href="Text.html">Text</a></li></li><li><li><a href="Time.html">Time</a></li></li><li><li><a href="Timer.html">Timer</a></li></li><li><li><a href="Tuples.html">Tuples</a></li></li><li><li><a href="Types.html">Types</a></li></li><li><li><a href="VarArray.html">VarArray</a></li></li><li><li><a href="internal/BTreeHelper.html">internal/BTreeHelper</a></li></li><li><li><a href="internal/PRNG.html">internal/PRNG</a></li></li><li><li><a href="pure/List.html">pure/List</a></li></li><li><li><a href="pure/Map.html">pure/Map</a></li></li><li><li><a href="pure/Queue.html">pure/Queue</a></li></li><li><li><a href="pure/Set.html">pure/Set</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#type.Set">Set</a></li></li><li><li><a href="#toPure">toPure</a></li></li><li><li><a href="#fromPure">fromPure</a></li></li><li><li><a href="#clone">clone</a></li></li><li><li><a href="#empty">empty</a></li></li><li><li><a href="#singleton">singleton</a></li></li><li><li><a href="#clear">clear</a></li></li><li><li><a href="#isEmpty">isEmpty</a></li></li><li><li><a href="#size">size</a></li></li><li><li><a href="#equal">equal</a></li></li><li><li><a href="#contains">contains</a></li></li><li><li><a href="#add">add</a></li></li><li><li><a href="#insert">insert</a></li></li><li><li><a href="#remove">remove</a></li></li><li><li><a href="#delete">delete</a></li></li><li><li><a href="#max">max</a></li></li><li><li><a href="#min">min</a></li></li><li><li><a href="#values">values</a></li></li><li><li><a href="#reverseValues">reverseValues</a></li></li><li><li><a href="#fromIter">fromIter</a></li></li><li><li><a href="#isSubset">isSubset</a></li></li><li><li><a href="#union">union</a></li></li><li><li><a href="#intersection">intersection</a></li></li><li><li><a href="#difference">difference</a></li></li><li><li><a href="#addAll">addAll</a></li></li><li><li><a href="#deleteAll">deleteAll</a></li></li><li><li><a href="#insertAll">insertAll</a></li></li><li><li><a href="#retainAll">retainAll</a></li></li><li><li><a href="#forEach">forEach</a></li></li><li><li><a href="#filter">filter</a></li></li><li><li><a href="#map">map</a></li></li><li><li><a href="#filterMap">filterMap</a></li></li><li><li><a href="#foldLeft">foldLeft</a></li></li><li><li><a href="#foldRight">foldRight</a></li></li><li><li><a href="#join">join</a></li></li><li><li><a href="#flatten">flatten</a></li></li><li><li><a href="#all">all</a></li></li><li><li><a href="#any">any</a></li></li><li><li><a href="#assertValid">assertValid</a></li></li><li><li><a href="#toText">toText</a></li></li><li><li><a href="#compare">compare</a></li></li></ul></nav><div class="documentation"><h1>Set</h1><p>An imperative set based on order/comparison of the elements.
A set is a collection of elements without duplicates.
The set data structure type is stable and can be used for orthogonal persistence.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let userIds = Set.empty&lt;Nat&gt;();
  Set.add(userIds, Nat.compare, 1);
  Set.add(userIds, Nat.compare, 2);
  Set.add(userIds, Nat.compare, 3);
}</code></pre>

<p>The internal implementation is a B-tree with order 32.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire set.
<code>n</code> denotes the number of elements stored in the set.</li></ul><div class="declaration"><h4 class="type-declaration" id="type.Set"><span class="keyword">type </span><span class="type">Set</span>&lt;<span class="type">T</span>&gt; = <a href="Types.html#Set.type.Set"><span class="type">Types.Set.Set</span></a>&lt;<span class="type">T</span>&gt;</h4><p></p></div><div class="declaration"><h4 class="function" id="toPure"><code><span class="keyword">public func </span><span class="fnname">toPure</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>) : <a href="pure/Set.html#type.Set"><span class="type">PureSet.Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Convert the mutable set to an immutable, purely functional set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import PureSet &quot;mo:base/pure/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);
  let pureSet = Set.toPure(set, Nat.compare);
  assert(PureSet.contains(pureSet, Nat.compare, 1));
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(n)</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: Creates <code>O(n * log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="fromPure"><code><span class="keyword">public func </span><span class="fnname">fromPure</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="pure/Set.html#type.Set"><span class="type">PureSet.Set</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Convert an immutable, purely functional set to a mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import PureSet &quot;mo:base/pure/Set&quot;;
import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  var pureSet = PureSet.empty&lt;Nat&gt;();
  pureSet := PureSet.add(pureSet, Nat.compare, 1);
  pureSet := PureSet.add(pureSet, Nat.compare, 2);
  pureSet := PureSet.add(pureSet, Nat.compare, 3);
  let mutableSet = Set.fromPure(pureSet, Nat.compare);
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(n)</code>.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="clone"><code><span class="keyword">public func </span><span class="fnname">clone</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a copy of the mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let originalSet = Set.empty&lt;Nat&gt;();
  Set.add(originalSet, Nat.compare, 1);
  Set.add(originalSet, Nat.compare, 2);
  Set.add(originalSet, Nat.compare, 3);
  let clonedSet = Set.clone(originalSet);
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(n)</code>.
where <code>n</code> denotes the number of elements stored in the set.</p>
</p></div><div class="declaration"><h4 class="function" id="empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>&lt;<span class="type">T</span>&gt;() : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a new empty mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Debug.print(Nat.toText(Set.size(set))); // prints `0`
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="singleton"><code><span class="keyword">public func </span><span class="fnname">singleton</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">element</span> : <span class="type">T</span>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a new mutable set with a single element.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let cities = Set.singleton&lt;Text&gt;(&quot;Zurich&quot;);
  Debug.print(debug_show(Set.size(cities))); // prints `1`
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="clear"><code><span class="keyword">public func </span><span class="fnname">clear</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;)</code></h4><p><p>Remove all the elements from the set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Text &quot;mo:base/Text&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let cities = Set.empty&lt;Text&gt;();
  Set.add(cities, Text.compare, &quot;Zurich&quot;);
  Set.add(cities, Text.compare, &quot;San Francisco&quot;);
  Set.add(cities, Text.compare, &quot;London&quot;);
  Debug.print(debug_show(Set.size(cities))); // prints `3`

  Set.clear(cities);
  Debug.print(debug_show(Set.size(cities))); // prints `0`
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Bool</span></code></h4><p><p>Determines whether a set is empty.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  Debug.print(debug_show(Set.isEmpty(set))); // prints `false`
  Set.clear(set);
  Debug.print(debug_show(Set.isEmpty(set))); // prints `true`
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;) : <span class="type">Nat</span></code></h4><p><p>Return the number of elements in a set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  Debug.print(Nat.toText(Set.size(set))); // prints `3`
}</code></pre>

<p>Runtime: <code>O(1)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="equal"><code><span class="keyword">public func </span><span class="fnname">equal</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set1</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">set2</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Types.html#type.Order"><span class="type">Types.Order</span></a><br/>) : <span class="type">Bool</span></code></h4><p><p>Test whether two imperative sets are equal.
Both sets have to be constructed by the same comparison function.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let set1 = Set.empty&lt;Nat&gt;();
  Set.add(set1, Nat.compare, 1);
  Set.add(set1, Nat.compare, 2);
  Set.add(set1, Nat.compare, 3);
  let set2 = Set.clone(set1);

  assert Set.equal(set1, set2, Nat.compare);
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code>.</p>
</p></div><div class="declaration"><h4 class="function" id="contains"><code><span class="keyword">public func </span><span class="fnname">contains</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Tests whether the set contains the provided element.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Bool &quot;mo:base/Bool&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  Debug.print(Bool.toText(Set.contains(set, Nat.compare, 1))); // prints `true`
  Debug.print(Bool.toText(Set.contains(set, Nat.compare, 4))); // prints `false`
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="add"><code><span class="keyword">public func </span><span class="fnname">add</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>)</code></h4><p><p>Add a new element to a set.
No effect if the element already exists in the set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code>.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="insert"><code><span class="keyword">public func </span><span class="fnname">insert</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Insert a new element in the set.
Returns true if the element is new, false if the element was already contained in the set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  assert Set.insert(set, Nat.compare, 1);
  assert Set.insert(set, Nat.compare, 2);
  assert Set.insert(set, Nat.compare, 3);
  assert not (Set.insert(set, Nat.compare, 3));
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code>.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="remove"><code><span class="keyword">public func </span><span class="fnname">remove</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>) : ()</code></h4><p><p>Deletes an element from a set.
Returns <code>true</code> if the element was contained in the set, <code>false</code> if not.</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  Set.remove(set, Nat.compare, 1);
  Debug.print(debug_show(Set.contains(set, Nat.compare, 1))); // prints `false`.

  Set.remove(set, Nat.compare, 4);
  Debug.print(debug_show(Set.contains(set, Nat.compare, 4))); // prints `false`.
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code> including garbage, see below.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: Creates <code>O(log(n))</code> objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="delete"><code><span class="keyword">public func </span><span class="fnname">delete</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">element</span> : <span class="type">T</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Deletes an element from a set.
Returns true if the element was contained in the set, false if not.</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  assert (Set.delete(set, Nat.compare, 1)); // delete returns true
  Debug.print(debug_show(Set.contains(set, Nat.compare, 1))); // prints `false`.

  assert (not Set.delete(set, Nat.compare, 4)); // delete returns false
  Debug.print(debug_show(Set.contains(set, Nat.compare, 4))); // prints `false`.
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(log(n))</code> including garbage, see below.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: Creates <code>O(log(n))</code> objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="max"><code><span class="keyword">public func </span><span class="fnname">max</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Retrieves the maximum element from the set.
If the set is empty, returns <code>null</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);
  Debug.print(debug_show(Set.max(set))); // prints `?3`.
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of elements stored in the set.</p>
</p></div><div class="declaration"><h4 class="function" id="min"><code><span class="keyword">public func </span><span class="fnname">min</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;) : ?<span class="type">T</span></code></h4><p><p>Retrieves the minimum element from the set.
If the set is empty, returns <code>null</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);
  Debug.print(debug_show(Set.min(set))); // prints `?1`.
}</code></pre>

<p>Runtime: <code>O(log(n))</code>.
Space: <code>O(1)</code>.
where <code>n</code> denotes the number of elements stored in the set.</p>
</p></div><div class="declaration"><h4 class="function" id="values"><code><span class="keyword">public func </span><span class="fnname">values</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;) : <a href="Types.html#type.Iter"><span class="type">Types.Iter</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns an iterator over the elements in the set,
traversing the elements in the ascending order.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  for (number in Set.values(set)) {
     Debug.print(debug_show(number));
  }
  // prints:
  // `1`
  // `2`
  // `3`
}</code></pre><p>Cost of iteration over all elements:
Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="reverseValues"><code><span class="keyword">public func </span><span class="fnname">reverseValues</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;) : <a href="Types.html#type.Iter"><span class="type">Types.Iter</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns an iterator over the elements in the set,
traversing the elements in the descending order.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  for (number in Set.reverseValues(set)) {
     Debug.print(debug_show(number));
  }
  // prints:
  // `3`
  // `2`
  // `1`
}</code></pre><p>Cost of iteration over all elements:
Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="fromIter"><code><span class="keyword">public func </span><span class="fnname">fromIter</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">iter</span> : <a href="Types.html#type.Iter"><span class="type">Types.Iter</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Create a mutable set with the elements obtained from an iterator.
Potential duplicate elements in the iterator are ignored, i.e.
multiple occurrence of an equal element only occur once in the set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;

persistent actor {
  transient let iterator = Iter.fromArray([3, 1, 2, 1]);
  let set = Set.fromIter&lt;Nat&gt;(iterator, Nat.compare);  // =&gt; {1, 2, 3}
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(n)</code>.
where <code>n</code> denotes the number of elements returned by the iterator and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="isSubset"><code><span class="keyword">public func </span><span class="fnname">isSubset</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set1</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">set2</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <span class="type">Bool</span></code></h4><p><p>Test whether <code>set1</code> is a sub-set of <code>set2</code>, i.e. each element in <code>set1</code> is
also contained in <code>set2</code>. Returns <code>true</code> if both sets are equal.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set1 = Set.fromIter(Iter.fromArray([1, 2]), Nat.compare);
  let set2 = Set.fromIter(Iter.fromArray([0, 1, 2]), Nat.compare);
  Debug.print(debug_show(Set.isSubset(set1, set2, Nat.compare))); // prints `true`.
}</code></pre>

<p>Runtime: <code>O(m * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>m</code> and <code>n</code> denote the number of elements stored in the sets <code>set1</code> and <code>set2</code>, respectively,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="union"><code><span class="keyword">public func </span><span class="fnname">union</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set1</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">set2</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns a new set that is the union of <code>set1</code> and <code>set2</code>,
i.e. a new set that all the elements that exist in at least on of the two sets.
Potential duplicates are ignored, i.e. if the same element occurs in both <code>set1</code>
and <code>set2</code>, it only occurs once in the returned set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set1 = Set.fromIter(Iter.fromArray([1, 2, 3]), Nat.compare);
  let set2 = Set.fromIter(Iter.fromArray([3, 4, 5]), Nat.compare);
  let union = Set.union(set1, set2, Nat.compare);
  Debug.print(debug_show(Iter.toArray(Set.values(union)))); // =&gt; [1, 2, 3, 4, 5]
}</code></pre>

<p>Runtime: <code>O(m * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>m</code> and <code>n</code> denote the number of elements stored in the sets <code>set1</code> and <code>set2</code>, respectively,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="intersection"><code><span class="keyword">public func </span><span class="fnname">intersection</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set1</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">set2</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns a new set that is the intersection of <code>set1</code> and <code>set2</code>,
i.e. a new set that contains all the elements that exist in both sets.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set1 = Set.fromIter(Iter.fromArray([0, 1, 2]), Nat.compare);
  let set2 = Set.fromIter(Iter.fromArray([1, 2, 3]), Nat.compare);
  let intersection = Set.intersection(set1, set2, Nat.compare);
  Debug.print(debug_show(Iter.toArray(Set.values(intersection)))); // =&gt; [1, 2]
}</code></pre>

<p>Runtime: <code>O(m * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>m</code> and <code>n</code> denote the number of elements stored in the sets <code>set1</code> and <code>set2</code>, respectively,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="difference"><code><span class="keyword">public func </span><span class="fnname">difference</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set1</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">set2</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Returns a new set that is the difference between <code>set1</code> and <code>set2</code> (<code>set1</code> minus <code>set2</code>),
i.e. a new set that contains all the elements of <code>set1</code> that do not exist in <code>set2</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set1 = Set.fromIter(Iter.fromArray([1, 2, 3]), Nat.compare);
  let set2 = Set.fromIter(Iter.fromArray([3, 4, 5]), Nat.compare);
  let difference = Set.difference(set1, set2, Nat.compare);
  assert Iter.toArray(Set.values(difference)) == [1, 2];
}</code></pre>

<p>Runtime: <code>O(m * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>m</code> and <code>n</code> denote the number of elements stored in the sets <code>set1</code> and <code>set2</code>, respectively,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="addAll"><code><span class="keyword">public func </span><span class="fnname">addAll</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">iter</span> : <a href="Types.html#type.Iter"><span class="type">Types.Iter</span></a>&lt;<span class="type">T</span>&gt;<br/>)</code></h4><p><p>Adds all elements from <code>iter</code> to the specified <code>set</code>.
This is equivalent to <code>Set.union()</code> but modifies the set in place.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.fromIter(Iter.fromArray([1, 2, 3]), Nat.compare);
  let iter = Iter.fromArray([3, 4, 5]);
  Set.addAll(set, Nat.compare, iter);
  assert Iter.toArray(Set.values(set)) == [1, 2, 3, 4, 5];
}</code></pre>

<p>Runtime: <code>O(m * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>m</code> and <code>n</code> denote the number of elements in <code>set</code> and <code>iter</code>, respectively,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="deleteAll"><code><span class="keyword">public func </span><span class="fnname">deleteAll</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">iter</span> : <a href="Types.html#type.Iter"><span class="type">Types.Iter</span></a>&lt;<span class="type">T</span>&gt;<br/>) : <span class="type">Bool</span></code></h4><p><p>Deletes all values in <code>iter</code> from the specified <code>set</code>.
Returns <code>true</code> if any value was present in the set, otherwise false.
The return value indicates whether the size of the set has changed.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.fromIter(Iter.fromArray([0, 1, 2]), Nat.compare);
  let iter = Iter.fromArray([0, 2]);
  assert Set.deleteAll(set, Nat.compare, iter);
  Debug.print(debug_show(Iter.toArray(Set.values(set)))); // =&gt; [1]
}</code></pre>

<p>Runtime: <code>O(m * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>m</code> and <code>n</code> denote the number of elements in <code>set</code> and <code>iter</code>, respectively,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="insertAll"><code><span class="keyword">public func </span><span class="fnname">insertAll</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">iter</span> : <a href="Types.html#type.Iter"><span class="type">Types.Iter</span></a>&lt;<span class="type">T</span>&gt;<br/>) : <span class="type">Bool</span></code></h4><p><p>Inserts all values in <code>iter</code> into <code>set</code>.
Returns true if any value was not contained in the original set, otherwise false.
The return value indicates whether the size of the set has changed.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.fromIter(Iter.fromArray([0, 1, 2]), Nat.compare);
  let iter = Iter.fromArray([0, 2, 3]);
  assert Set.insertAll(set, Nat.compare, iter);
  Debug.print(debug_show(Iter.toArray(Set.values(set)))); // =&gt; [0, 1, 2, 3]
}</code></pre>

<p>Runtime: <code>O(m * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>m</code> and <code>n</code> denote the number of elements in <code>set</code> and <code>iter</code>, respectively,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="retainAll"><code><span class="keyword">public func </span><span class="fnname">retainAll</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p><p>Removes all values in <code>set</code> that do not satisfy the given predicate.
Returns <code>true</code> if and only if the size of the set has changed.
Modifies the set in place.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);
  Set.retainAll(set, Nat.compare, func (n) { n % 2 == 0 });
  Debug.print(debug_show(Iter.toArray(Set.values(set)))); // =&gt; [2]
}</code></pre></p></div><div class="declaration"><h4 class="function" id="forEach"><code><span class="keyword">public func </span><span class="fnname">forEach</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">operation</span> : <span class="type">T</span> -&gt; ())</code></h4><p><p>Apply an operation on each element contained in the set.
The operation is applied in ascending order of the elements.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  Set.forEach&lt;Nat&gt;(set, func (element) {
    Debug.print(&quot;element=&quot; # Nat.toText(element));
  })
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="filter"><code><span class="keyword">public func </span><span class="fnname">filter</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">criterion</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span><br/>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Filter elements in a new set.
Create a copy of the mutable set that only contains the elements
that fulfil the criterion function.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let numbers = Set.empty&lt;Nat&gt;();
  Set.add(numbers, Nat.compare, 1);
  Set.add(numbers, Nat.compare, 2);
  Set.add(numbers, Nat.compare, 3);

  let evenNumbers = Set.filter&lt;Nat&gt;(numbers, Nat.compare, func (number) {
    number % 2 == 0
  });
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(n)</code>.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="map"><code><span class="keyword">public func </span><span class="fnname">map</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T1</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T2</span>, <span class="type">T2</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">project</span> : <span class="type">T1</span> -&gt; <span class="type">T2</span><br/>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T2</span>&gt;</code></h4><p><p>Project all elements of the set in a new set.
Apply a mapping function to each element in the set and
collect the mapped elements in a new mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Text &quot;mo:base/Text&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let numbers = Set.empty&lt;Nat&gt;();
  Set.add(numbers, Nat.compare, 1);
  Set.add(numbers, Nat.compare, 2);
  Set.add(numbers, Nat.compare, 3);

  let textNumbers = Set.map&lt;Nat, Text&gt;(numbers, Text.compare, func (number) {
    Nat.toText(number)
  });
  for (textNumbers in Set.values(textNumbers)) {
     Debug.print(debug_show(textNumbers));
  }
  // prints:
  // `&quot;1&quot;`
  // `&quot;2&quot;`
  // `&quot;3&quot;`
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(n)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set and
assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="filterMap"><code><span class="keyword">public func </span><span class="fnname">filterMap</span>&lt;<span class="type">T1</span>, <span class="type">T2</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T1</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T2</span>, <span class="type">T2</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>, <br/>  <span class="parameter">project</span> : <span class="type">T1</span> -&gt; ?<span class="type">T2</span><br/>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T2</span>&gt;</code></h4><p><p>Filter all elements in the set by also applying a projection to the elements.
Apply a mapping function <code>project</code> to all elements in the set and collect all
elements, for which the function returns a non-null new element. Collect all
non-discarded new elements in a new mutable set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Text &quot;mo:base/Text&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let numbers = Set.empty&lt;Nat&gt;();
  Set.add(numbers, Nat.compare, 0);
  Set.add(numbers, Nat.compare, 1);
  Set.add(numbers, Nat.compare, 2);
  Set.add(numbers, Nat.compare, 3);

  let evenTextNumbers = Set.filterMap&lt;Nat, Text&gt;(numbers, Text.compare, func (number) {
    if (number % 2 == 0) {
       ?Nat.toText(number)
    } else {
       null // discard odd numbers
    }
  });
  for (textNumber in Set.values(evenTextNumbers)) {
     Debug.print(textNumber);
  }
  // prints:
  // `&quot;0&quot;`
  // `&quot;2&quot;`
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(n)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="foldLeft"><code><span class="keyword">public func </span><span class="fnname">foldLeft</span>&lt;<span class="type">T</span>, <span class="type">A</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">A</span>, <span class="type">T</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Iterate all elements in ascending order,
and accumulate the elements by applying the combine function, starting from a base value.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  let text = Set.foldLeft&lt;Nat, Text&gt;(
     set,
     &quot;&quot;,
     func (accumulator, element) {
       let separator = if (accumulator != &quot;&quot;) { &quot;, &quot; } else { &quot;&quot; };
       accumulator # separator # Nat.toText(element)
     }
  );
  Debug.print(text);
  // prints `1, 2, 3`.
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="foldRight"><code><span class="keyword">public func </span><span class="fnname">foldRight</span>&lt;<span class="type">T</span>, <span class="type">A</span>&gt;(<br/>  <span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">base</span> : <span class="type">A</span>, <br/>  <span class="parameter">combine</span> : (<span class="type">T</span>, <span class="type">A</span>) -&gt; <span class="type">A</span><br/>) : <span class="type">A</span></code></h4><p><p>Iterate all elements in descending order,
and accumulate the elements by applying the combine function, starting from a base value.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  let text = Set.foldRight&lt;Nat, Text&gt;(
     set,
     &quot;&quot;,
     func (element, accumulator) {
       let separator = if (accumulator != &quot;&quot;) { &quot;, &quot; } else { &quot;&quot; };
       accumulator # separator # Nat.toText(element)
     }
  );
  Debug.print(text);
  // prints `2, 1, 0`
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="join"><code><span class="keyword">public func </span><span class="fnname">join</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">setIterator</span> : <a href="Types.html#type.Iter"><span class="type">Types.Iter</span></a>&lt;<a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Construct the union of a series of sets, i.e. all elements of
each set are included in the result set.
Any duplicates are ignored, i.e. if an element occurs
in several of the iterated sets, it only occurs once in the result set.</p>
<p>Assumes all sets are ordered by <code>compare</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  let set1 = Set.fromIter(Iter.fromArray([1, 2, 3]), Nat.compare);
  let set2 = Set.fromIter(Iter.fromArray([3, 4, 5]), Nat.compare);
  let set3 = Set.fromIter(Iter.fromArray([5, 6, 7]), Nat.compare);
  transient let iterator = Iter.fromArray([set1, set2, set3]);
  let combined = Set.join(iterator, Nat.compare);
  Debug.print(debug_show(Iter.toArray(Set.values(combined))));
  // prints: `[1, 2, 3, 4, 5, 6, 7]`.
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of elements stored in the iterated sets,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="flatten"><code><span class="keyword">public func </span><span class="fnname">flatten</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">setOfSets</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>) : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;</code></h4><p><p>Construct the union of a set of element sets, i.e. all elements of
each element set are included in the result set.
Any duplicates are ignored, i.e. if the same element occurs in multiple element sets,
it only occurs once in the result set.</p>
<p>Assumes all sets are ordered by <code>compare</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Order &quot;mo:base/Order&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

persistent actor {
  func setCompare(first: Set.Set&lt;Nat&gt;, second: Set.Set&lt;Nat&gt;) : Order.Order {
     Set.compare(first, second, Nat.compare)
  };

  let subSet1 = Set.fromIter(Iter.fromArray([1, 2, 3]), Nat.compare);
  let subSet2 = Set.fromIter(Iter.fromArray([3, 4, 5]), Nat.compare);
  let subSet3 = Set.fromIter(Iter.fromArray([5, 6, 7]), Nat.compare);
  let setOfSets = Set.fromIter(Iter.fromArray([subSet1, subSet2, subSet3]), setCompare);
  let flatSet = Set.flatten(setOfSets, Nat.compare);
  Debug.print(debug_show(Iter.toArray(Set.values(flatSet))));
  // prints: `[1, 2, 3, 4, 5, 6, 7]`.
}</code></pre>

<p>Runtime: <code>O(n * log(n))</code>.
Space: <code>O(1)</code> retained memory plus garbage, see the note below.
where <code>n</code> denotes the number of elements stored in all the sub-sets,
and assuming that the <code>compare</code> function implements an <code>O(1)</code> comparison.</p>
</p></div><div class="declaration"><h4 class="function" id="all"><code><span class="keyword">public func </span><span class="fnname">all</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Check whether all elements in the set satisfy a predicate, i.e.
the <code>predicate</code> function returns <code>true</code> for all elements in the set.
Returns <code>true</code> for an empty set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  let belowTen = Set.all&lt;Nat&gt;(set, func (number) {
    number &lt; 10
  }); // `true`
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="any"><code><span class="keyword">public func </span><span class="fnname">any</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">predicate</span> : <span class="type">T</span> -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p><p>Check whether at least one element in the set satisfies a predicate, i.e.
the <code>predicate</code> function returns <code>true</code> for at least one element in the set.
Returns <code>false</code> for an empty set.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  let aboveTen = Set.any&lt;Nat&gt;(set, func (number) {
    number &gt; 10
  }); // `false`
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="assertValid"><code><span class="keyword">public func </span><span class="fnname">assertValid</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a>)</code></h4><p><p>Internal sanity check function.
Can be used to check that elements have been inserted with a consistent comparison function.
Traps if the internal set structure is invalid.</p>
</p></div><div class="declaration"><h4 class="function" id="toText"><code><span class="keyword">public func </span><span class="fnname">toText</span>&lt;<span class="type">T</span>&gt;(<span class="parameter">set</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <span class="parameter">elementFormat</span> : <span class="type">T</span> -&gt; <span class="type">Text</span>) : <span class="type">Text</span></code></h4><p><p>Generate a textual representation of all the elements in the set.
Primarily to be used for testing and debugging.
The elements are formatted according to <code>elementFormat</code>.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;

persistent actor {
  let set = Set.empty&lt;Nat&gt;();
  Set.add(set, Nat.compare, 1);
  Set.add(set, Nat.compare, 2);
  Set.add(set, Nat.compare, 3);

  let text = Set.toText&lt;Nat&gt;(set, Nat.toText);
  // `&quot;{0, 1, 2}&quot;`
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(n)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set and
assuming that <code>elementFormat</code> has runtime and space costs of <code>O(1)</code>.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div><div class="declaration"><h4 class="function" id="compare"><code><span class="keyword">public func </span><span class="fnname">compare</span>&lt;<span class="type">T</span>&gt;(<br/>  <span class="parameter">set1</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">set2</span> : <a href="#type.Set"><span class="type">Set</span></a>&lt;<span class="type">T</span>&gt;, <br/>  <span class="parameter">compare</span> : (<span class="type">T</span>, <span class="type">T</span>) -&gt; <a href="Order.html#type.Order"><span class="type">Order.Order</span></a><br/>) : <a href="Order.html#type.Order"><span class="type">Order.Order</span></a></code></h4><p><p>Compare two sets by comparing the elements.
Both sets must have been created by the same comparison function.
The two sets are iterated by the ascending order of their creation and
order is determined by the following rules:
Less:
<code>set1</code> is less than <code>set2</code> if:</p>
<ul><li>the pairwise iteration hits an element pair <code>element1</code> and <code>element2</code> where
 <code>element1</code> is less than <code>element2</code> and all preceding elements are equal, or,</li><li><code>set1</code> is  a strict prefix of <code>set2</code>, i.e. <code>set2</code> has more elements than <code>set1</code>
 and all elements of <code>set1</code> occur at the beginning of iteration <code>set2</code>.
Equal:
<code>set1</code> and <code>set2</code> have same series of equal elements by pairwise iteration.
Greater:
<code>set1</code> is neither less nor equal <code>set2</code>.</li></ul>

<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:base/Set&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Text &quot;mo:base/Text&quot;;

persistent actor {
  let set1 = Set.empty&lt;Nat&gt;();
  Set.add(set1, Nat.compare, 0);
  Set.add(set1, Nat.compare, 1);

  let set2 = Set.empty&lt;Nat&gt;();
  Set.add(set2, Nat.compare, 0);
  Set.add(set2, Nat.compare, 2);

  let orderLess = Set.compare(set1, set2, Nat.compare);
  // `#less`
  let orderEqual = Set.compare(set1, set1, Nat.compare);
  // `#equal`
  let orderGreater = Set.compare(set2, set1, Nat.compare);
  // `#greater`
}</code></pre>

<p>Runtime: <code>O(n)</code>.
Space: <code>O(1)</code> retained memory plus garbage, see below.
where <code>n</code> denotes the number of elements stored in the set and
assuming that <code>compare</code> has runtime and space costs of <code>O(1)</code>.</p>
<p>Note: Creates <code>O(log(n))</code> temporary objects that will be collected as garbage.</p>
</p></div></div></body></html>