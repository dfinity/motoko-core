<!DOCTYPE html>
<html><head title="Motoko docs"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><div class="index-container"><h1 class="index-header">Motoko package</h1><ul class="index-listing"><li class="index-item"><a class="index-item-link" href="Array.html">Array</a><div class="index-item-comment"><p>Provides extended utility functions on immutable Arrays (values of type <code>[T]</code>).</p>
<p>Note the difference between mutable (<code>[var T]</code>) and immutable (<code>[T]</code>) arrays.
Mutable arrays allow their elements to be modified after creation, while
immutable arrays are fixed once created.</p>
<p>WARNING: If you are looking for a list that can grow and shrink in size,
it is recommended you use <code>List</code> for those purposes.
Arrays must be created with a fixed size.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Array &quot;mo:core/Array&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Blob.html">Blob</a><div class="index-item-comment"><p>Module for working with Blobs (immutable sequences of bytes).</p>
<p>Blobs represent sequences of bytes. They are immutable, iterable, but not indexable and can be empty.</p>
<p>Byte sequences are also often represented as <code>[Nat8]</code>, i.e. an array of bytes, but this representation is currently much less compact than <code>Blob</code>, taking 4 physical bytes to represent each logical byte in the sequence.
If you would like to manipulate Blobs, it is recommended that you convert
Blobs to <code>[var Nat8]</code> or <code>Buffer&lt;Nat8&gt;</code>, do the manipulation, then convert back.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Blob &quot;mo:core/Blob&quot;;</code></pre>

<p>Some built in features not listed in this module:</p>
<ul><li>You can create a <code>Blob</code> literal from a <code>Text</code> literal, provided the context expects an expression of type <code>Blob</code>.</li><li><code>b.size() : Nat</code> returns the number of bytes in the blob <code>b</code>;</li><li><code>b.values() : Iter.Iter&lt;Nat8&gt;</code> returns an iterator to enumerate the bytes of the blob <code>b</code>.</li></ul>

<p>For example:</p>
<pre><code>motoko include=import
import Debug &quot;mo:core/Debug&quot;;
import Nat8 &quot;mo:core/Nat8&quot;;

let blob = &quot;\00\00\00\ff&quot; : Blob; // blob literals, where each byte is delimited by a back-slash and represented in hex
let blob2 = &quot;charsもあり&quot; : Blob; // you can also use characters in the literals
let numBytes = blob.size();
assert numBytes == 4; // returns the number of bytes in the Blob
for (byte in blob.values()) { // iterator over the Blob
  Debug.print(Nat8.toText(byte))
}</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Bool.html">Bool</a><div class="index-item-comment"><p>Boolean type and operations.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Bool &quot;mo:core/Bool&quot;;</code></pre>

<p>While boolean operators <code>_ and _</code> and <code>_ or _</code> are short-circuiting,
avoiding computation of the right argument when possible, the functions
<code>logicalAnd(_, _)</code> and <code>logicalOr(_, _)</code> are <em>strict</em> and will always evaluate <em>both</em>
of their arguments.</p>
<p>Example:</p>
<pre><code>motoko include=import
let t = true;
let f = false;

// Short-circuiting AND
assert not (t and f);

// Short-circuiting OR
assert t or f;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="CertifiedData.html">CertifiedData</a><div class="index-item-comment"><p>Certified data.</p>
<p>The Internet Computer allows canister smart contracts to store a small amount of data during
update method processing so that during query call processing, the canister can obtain
a certificate about that data.</p>
<p>This module provides a <em>low-level</em> interface to this API, aimed at advanced
users and library implementors. See the Internet Computer Functional
Specification and corresponding documentation for how to use this to make query
calls to your canister tamperproof.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Char.html">Char</a><div class="index-item-comment"><p>Module for working with Characters (Unicode code points).</p>
<p>Characters in Motoko represent Unicode code points
in the range 0 to 0x10FFFF, excluding the surrogate code points
(0xD800 through 0xDFFF).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Char &quot;mo:core/Char&quot;;</code></pre>

<p>Some built in features not listed in this module:</p>
<ul><li>You can create a <code>Char</code> literal using single quotes, e.g. 'A', '1', '漢'</li><li>You can compare characters using <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, <code>&gt;</code> operators</li><li>You can convert a single-character <code>Text</code> to a <code>Char</code> using <code>:Char</code> type annotation</li></ul>

<p>For example:</p>
<pre><code>motoko include=import
let char : Char = 'A';
let unicodeChar = '漢';
let digit = '7';
assert Char.isDigit(digit);
assert Char.toText(char) == &quot;A&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Cycles.html">Cycles</a><div class="index-item-comment"><p>Managing cycles within actors in the Internet Computer Protocol (ICP).</p>
<p>The usage of the Internet Computer is measured, and paid for, in <em>cycles</em>.
This library provides imperative operations for observing cycles, transferring cycles, and
observing refunds of cycles.</p>
<p><strong>NOTE:</strong> Since cycles measure computational resources, the value of  <code>balance()</code> can change from one call to the next.</p>
<p>Cycles can be transferred from the current actor to another actor with the evaluation of certain forms of expression.
In particular, the expression must be a call to a shared function, a call to a local function with an <code>async</code> return type, or a simple <code>async</code> expression.
To attach an amount of cycles to an expression <code>&lt;exp&gt;</code>, simply prefix the expression with <code>(with cycles = &lt;amount&gt;)</code>, that is, <code>(with cycles = &lt;amount&gt;) &lt;exp&gt;</code>.</p>
<p><strong>NOTE:</strong> Attaching cycles will trap if the amount specified exceeds <code>2 ** 128</code> cycles.</p>
<p>Upon the call, but not before, the amount of cycles is deducted from <code>balance()</code>.
If this total exceeds <code>balance()</code>, the caller traps, aborting the call without consuming the cycles.
Note that attaching cycles to a call to a local function call or <code>async</code> expression just transfers cycles from the current actor to itself.</p>
<p>Example for use on the ICP:</p>
<pre><code>motoko no-repl
import Cycles &quot;mo:core/Cycles&quot;;

persistent actor {
  public func main() : async () {
    let initialBalance = Cycles.balance();
    await (with cycles = 15_000_000) operation(); // accepts 10_000_000 cycles
    assert Cycles.refunded() == 5_000_000;
    assert Cycles.balance() &lt; initialBalance; // decreased by around 10_000_000
  };

  func operation() : async () {
    let initialBalance = Cycles.balance();
    let initialAvailable = Cycles.available();
    let obtained = Cycles.accept&lt;system&gt;(10_000_000);
    assert obtained == 10_000_000;
    assert Cycles.balance() == initialBalance + 10_000_000;
    assert Cycles.available() == initialAvailable - 10_000_000;
  }
}</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Debug.html">Debug</a><div class="index-item-comment"><p>Utility functions for debugging.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Debug &quot;mo:core/Debug&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Error.html">Error</a><div class="index-item-comment"><p>Error values and inspection.</p>
<p>The <code>Error</code> type is the argument to <code>throw</code>, parameter of <code>catch</code>.
The <code>Error</code> type is opaque.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Float.html">Float</a><div class="index-item-comment"><p>Double precision (64-bit) floating-point numbers in IEEE 754 representation.</p>
<p>This module contains common floating-point constants and utility functions.</p>
<pre><code>motoko name=import
import Float &quot;mo:core/Float&quot;;</code></pre>

<p>Notation for special values in the documentation below:
<code>+inf</code>: Positive infinity
<code>-inf</code>: Negative infinity
<code>NaN</code>: &quot;not a number&quot; (can have different sign bit values, but <code>NaN != NaN</code> regardless of the sign).</p>
<p>Note:
Floating point numbers have limited precision and operations may inherently result in numerical errors.</p>
<p>Examples of numerical errors:</p>
<pre class="motoko"><code class="motoko">  assert 0.1 + 0.1 + 0.1 != 0.3;
  </code></pre>

<pre class="motoko"><code class="motoko">  assert not (1e16 + 1.0 != 1e16);
  </code></pre>

<p> (and many more cases)</p>
<p>Advice:</p>
<ul><li>Floating point number comparisons by <code>==</code> or <code>!=</code> are discouraged. Instead, it is better to compare
 floating-point numbers with a numerical tolerance, called epsilon.</li></ul>

<p> Example:</p>
<pre class="motoko"><code class="motoko">  import Float &quot;mo:core/Float&quot;;
  let x = 0.1 + 0.1 + 0.1;
  let y = 0.3;

  let epsilon = 1e-6; // This depends on the application case (needs a numerical error analysis).
  assert Float.equal(x, y, epsilon);
  </code></pre>

<ul><li>For absolute precision, it is recommened to encode the fraction number as a pair of a Nat for the base
 and a Nat for the exponent (decimal point).</li></ul>

<p>NaN sign:</p>
<ul><li>The NaN sign is only applied by <code>abs</code>, <code>neg</code>, and <code>copySign</code>. Other operations can have an arbitrary
 sign bit for NaN results.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Func.html">Func</a><div class="index-item-comment"><p>Functions on functions, creating functions from simpler inputs.</p>
<p>(Most commonly used when programming in functional style using higher-order
functions.)</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Func = &quot;mo:core/Func&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int.html">Int</a><div class="index-item-comment"><p>Signed integer numbers with infinite precision (also called big integers).</p>
<p>Most operations on integer numbers (e.g. addition) are available as built-in operators (e.g. <code>-1 + 1</code>).
This module provides equivalent functions and <code>Text</code> conversion.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Int &quot;mo:core/Int&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int16.html">Int16</a><div class="index-item-comment"><p>Utility functions on 16-bit signed integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Int16 &quot;mo:core/Int16&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int32.html">Int32</a><div class="index-item-comment"><p>Utility functions on 32-bit signed integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Int32 &quot;mo:core/Int32&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int64.html">Int64</a><div class="index-item-comment"><p>Utility functions on 64-bit signed integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Int64 &quot;mo:core/Int64&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Int8.html">Int8</a><div class="index-item-comment"><p>Utility functions on 8-bit signed integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Int8 &quot;mo:core/Int8&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="InternetComputer.html">InternetComputer</a><div class="index-item-comment"><p>Low-level interface to the Internet Computer.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Iter.html">Iter</a><div class="index-item-comment"><p>Utilities for <code>Iter</code> (iterator) values.</p>
<p>Iterators are a way to represent sequences of values that can be lazily produced.
They can be used to:</p>
<ul><li>Iterate over collections.</li><li>Represent collections that are too large to fit in memory or that are produced incrementally.</li><li>Transform collections without creating intermediate collections.</li></ul>

<p>Iterators are inherently stateful. Calling <code>next</code> &quot;consumes&quot; a value from
the Iterator that cannot be put back, so keep that in mind when sharing
iterators between consumers.</p>
<pre><code>motoko name=import
import Iter &quot;mo:core/Iter&quot;;</code></pre>

<p>An iterator can be iterated over using a <code>for</code> loop:</p>
<pre class="motoko"><code class="motoko">let iter = [1, 2, 3].values();
for (x in iter) {
  // do something with x...
}</code></pre>

<p>Iterators can be:</p>
<ul><li>created from other collections (e.g. using <code>values</code> or <code>keys</code> function on a <code>Map</code>) or from scratch (e.g. using <code>empty</code> or <code>singleton</code>).</li><li>transformed using <code>map</code>, <code>filter</code>, <code>concat</code>, etc. Which can be used to compose several transformations together without materializing intermediate collections.</li><li>consumed using <code>forEach</code>, <code>size</code>, <code>toArray</code>, etc.</li><li>combined using <code>concat</code>.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="List.html">List</a><div class="index-item-comment"><p>A mutable growable array data structure with efficient random access and dynamic resizing.
<code>List</code> provides O(1) access time and O(sqrt(n)) memory overhead. In contrast, <code>pure/List</code> is a purely functional linked list.
Can be declared <code>stable</code> for orthogonal persistence.</p>
<p>This implementation is adapted with permission from the <code>vector</code> Mops package created by Research AG.</p>
<p>Copyright: 2023 MR Research AG
Main author: Andrii Stepanov
Contributors: Timo Hanke (timohanke), Andy Gura (andygura), react0r-com</p>
<pre><code>motoko name=import
import List &quot;mo:core/List&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat.html">Nat</a><div class="index-item-comment"><p>Natural numbers with infinite precision.</p>
<p>Most operations on natural numbers (e.g. addition) are available as built-in operators (e.g. <code>1 + 1</code>).
This module provides equivalent functions and <code>Text</code> conversion.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Nat &quot;mo:core/Nat&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat16.html">Nat16</a><div class="index-item-comment"><p>Utility functions on 16-bit unsigned integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Nat16 &quot;mo:core/Nat16&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat32.html">Nat32</a><div class="index-item-comment"><p>Utility functions on 32-bit unsigned integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Nat32 &quot;mo:core/Nat32&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat64.html">Nat64</a><div class="index-item-comment"><p>Utility functions on 64-bit unsigned integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Nat64 &quot;mo:core/Nat64&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Nat8.html">Nat8</a><div class="index-item-comment"><p>Utility functions on 8-bit unsigned integers.</p>
<p>Note that most operations are available as built-in operators (e.g. <code>1 + 1</code>).</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Nat8 &quot;mo:core/Nat8&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Option.html">Option</a><div class="index-item-comment"><p>Typesafe nullable values.</p>
<p>Optional values can be seen as a typesafe <code>null</code>. A value of type <code>?Int</code> can
be constructed with either <code>null</code> or <code>?42</code>. The simplest way to get at the
contents of an optional is to use pattern matching:</p>
<pre class="motoko"><code class="motoko">let optionalInt1 : ?Int = ?42;
let optionalInt2 : ?Int = null;

let int1orZero : Int = switch optionalInt1 {
  case null 0;
  case (?int) int;
};
assert int1orZero == 42;

let int2orZero : Int = switch optionalInt2 {
  case null 0;
  case (?int) int;
};
assert int2orZero == 0;</code></pre>

<p>The functions in this module capture some common operations when working
with optionals that can be more succinct than using pattern matching.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Order.html">Order</a><div class="index-item-comment"><p>Utilities for <code>Order</code> (comparison between two values).</p>
</div></li><li class="index-item"><a class="index-item-link" href="Principal.html">Principal</a><div class="index-item-comment"><p>Module for interacting with Principals (users and canisters).</p>
<p>Principals are used to identify entities that can interact with the Internet
Computer. These entities are either users or canisters.</p>
<p>Example textual representation of Principals:</p>
<p><code>un4fu-tqaaa-aaaab-qadjq-cai</code></p>
<p>In Motoko, there is a primitive Principal type called <code>Principal</code>. As an example
of where you might see Principals, you can access the Principal of the
caller of your shared function.</p>
<pre><code>motoko no-repl
persistent actor {
  public shared(msg) func foo() {
    let caller : Principal = msg.caller;
  };
}</code></pre>

<p>Then, you can use this module to work with the <code>Principal</code>.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Principal &quot;mo:core/Principal&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Queue.html">Queue</a><div class="index-item-comment"><p>A mutable double-ended queue of elements.
The queue has two ends, front and back.
Elements can be added and removed at the two ends.</p>
<p>This can be used for different use cases, such as:</p>
<ul><li>Queue (FIFO) by using <code>pushBack()</code> and <code>popFront()</code></li><li>Stack (LIFO) by using <code>pushFront()</code> and <code>popFront()</code>.</li></ul>

<p>Example:</p>
<pre class="motoko"><code class="motoko">import Queue &quot;mo:core/Queue&quot;;

persistent actor {
  let orders = Queue.empty&lt;Text&gt;();
  Queue.pushBack(orders, &quot;Motoko&quot;);
  Queue.pushBack(orders, &quot;Mops&quot;);
  Queue.pushBack(orders, &quot;IC&quot;);
  assert Queue.popFront(orders) == ?&quot;Motoko&quot;;
  assert Queue.popFront(orders) == ?&quot;Mops&quot;;
  assert Queue.popFront(orders) == ?&quot;IC&quot;;
  assert Queue.popFront(orders) == null;
}</code></pre>

<p>The internal implementation is a doubly-linked list.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(1)</code> for push, pop, and peek operations.</li><li>Space: <code>O(n)</code>.
<code>n</code> denotes the number of elements stored in the queue.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Random.html">Random</a><div class="index-item-comment"><p>Random number generation.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Random &quot;mo:core/Random&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Region.html">Region</a><div class="index-item-comment"><p>Byte-level access to isolated, virtual stable memory regions.</p>
<p>This is a moderately lightweight abstraction over IC <em>stable memory</em> and supports persisting
regions of binary data across Motoko upgrades.
Use of this module is fully compatible with Motoko's use of
<em>stable variables</em>, whose persistence mechanism also uses (real) IC stable memory internally, but does not interfere with this API.
It is also fully compatible with existing uses of the <code>ExperimentalStableMemory</code> library, which has a similar interface, but,
only supported a single memory region, without isolation between different applications.</p>
<p>The <code>Region</code> type is stable and can be used in stable data structures.</p>
<p>A new, empty <code>Region</code> is allocated using function <code>new()</code>.</p>
<p>Regions are stateful objects and can be distinguished by the numeric identifier returned by function <code>id(region)</code>.
Every region owns an initially empty, but growable sequence of virtual IC stable memory pages.
The current size, in pages, of a region is returned by function <code>size(region)</code>.
The size of a region determines the range, [ 0, ..., size(region)*2^16 ), of valid byte-offsets into the region; these offsets are used as the source and destination of <code>load</code>/<code>store</code> operations on the region.</p>
<p>Memory is allocated to a region, using function <code>grow(region, pages)</code>, sequentially and on demand, in units of 64KiB logical pages, starting with 0 allocated pages.
A call to <code>grow</code> may succeed, returning the previous size of the region, or fail, returning a sentinel value. New pages are zero initialized.</p>
<p>A size of a region can only grow and never shrink.
In addition, the stable memory pages allocated to a region will <em>not</em> be reclaimed by garbage collection, even
if the region object itself becomes unreachable.</p>
<p>Growth is capped by a soft limit on physical page count controlled by compile-time flag
<code>--max-stable-pages &lt;n&gt;</code> (the default is 65536, or 4GiB).</p>
<p>Each <code>load</code> operation loads from region relative byte address <code>offset</code> in little-endian
format using the natural bit-width of the type in question.
The operation traps if attempting to read beyond the current region size.</p>
<p>Each <code>store</code> operation stores to region relative byte address <code>offset</code> in little-endian format using the natural bit-width of the type in question.
The operation traps if attempting to write beyond the current region size.</p>
<p>Text values can be handled by using <code>Text.decodeUtf8</code> and <code>Text.encodeUtf8</code>, in conjunction with <code>loadBlob</code> and <code>storeBlob</code>.</p>
<p>The current region allocation and region contents are preserved across upgrades.</p>
<p>NB: The IC's actual stable memory size (<code>ic0.stable_size</code>) may exceed the
total page size reported by summing all regions sizes.
This (and the cap on growth) are to accommodate Motoko's stable variables and bookkeeping for regions.
Applications that plan to use Motoko stable variables sparingly or not at all can
increase <code>--max-stable-pages</code> as desired, approaching the IC maximum (initially 8GiB, then 32Gib, currently 64Gib).
All applications should reserve at least one page for stable variable data, even when no stable variables are used.</p>
<p>Usage:</p>
<pre><code>motoko no-repl name=import
import Region &quot;mo:core/Region&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Result.html">Result</a><div class="index-item-comment"><p>Module for error handling with the Result type.</p>
<p>The Result type is used for returning and propagating errors. It has two variants:
<code>#ok(Ok)</code>, representing success and containing a value, and <code>#err(Err)</code>, representing
error and containing an error value.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import Result &quot;mo:core/Result&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Runtime.html">Runtime</a><div class="index-item-comment"><p>Runtime utilities.
These functions were originally part of the <code>Debug</code> module.</p>
<pre><code>motoko name=import
import Runtime &quot;mo:core/Runtime&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Set.html">Set</a><div class="index-item-comment"><p>Imperative (mutable) sets based on order/comparison of elements.
A set is a collection of elements without duplicates.
The set data structure type is stable and can be used for orthogonal persistence.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:core/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter([3, 1, 2, 3].vals(), Nat.compare);
  assert Set.size(set) == 3;
  assert not Set.contains(set, Nat.compare, 4);
  let diff = Set.difference(set, set, Nat.compare);
  assert Set.isEmpty(diff);
}</code></pre>

<p>These sets are implemented as B-trees with order 32, a balanced search tree of ordered elements.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire tree,
where <code>n</code> denotes the number of elements stored in the set.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Stack.html">Stack</a><div class="index-item-comment"><p>A mutable stack data structure.
Elements can be pushed on top of the stack
and removed from top of the stack (LIFO).</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Stack &quot;mo:core/Stack&quot;;
import Debug &quot;mo:core/Debug&quot;;

persistent actor {
  let levels = Stack.empty&lt;Text&gt;();
  Stack.push(levels, &quot;Inner&quot;);
  Stack.push(levels, &quot;Middle&quot;);
  Stack.push(levels, &quot;Outer&quot;);
  assert Stack.pop(levels) == ?&quot;Outer&quot;;
  assert Stack.pop(levels) == ?&quot;Middle&quot;;
  assert Stack.pop(levels) == ?&quot;Inner&quot;;
  assert Stack.pop(levels) == null;
}</code></pre>

<p>The internal implementation is a singly-linked list.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(1)</code> for push, pop, and peek operation.</li><li>Space: <code>O(n)</code>.
<code>n</code> denotes the number of elements stored on the stack.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="Text.html">Text</a><div class="index-item-comment"><p>Utility functions for <code>Text</code> values.</p>
<p>A <code>Text</code> value represents human-readable text as a sequence of characters of type <code>Char</code>.</p>
<pre class="motoko"><code class="motoko">let text = &quot;Hello!&quot;;
let size = text.size();
assert size == 6;
let iter = text.chars();
assert iter.next() == ?'H';
assert iter.next() == ?'e';
assert iter.next() == ?'l';
assert iter.next() == ?'l';
assert iter.next() == ?'o';
assert iter.next() == ?'!';
assert iter.next() == null;
let concat = text # &quot; 👋&quot;;
assert concat == &quot;Hello! 👋&quot;;</code></pre>

<p>The <code>&quot;mo:core/Text&quot;</code> module defines additional operations on <code>Text</code> values.</p>
<p>Import the module from the core package:</p>
<pre><code>motoko name=import
import Text &quot;mo:core/Text&quot;;</code></pre>

<p>Note: <code>Text</code> values are represented as ropes of UTF-8 character sequences with O(1) concatenation.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Time.html">Time</a><div class="index-item-comment"><p>System time utilities and timers.</p>
<p>The following example illustrates using the system time:</p>
<pre class="motoko"><code class="motoko">import Int = &quot;mo:core/Int&quot;;
import Time = &quot;mo:core/Time&quot;;

persistent actor {
  var lastTime = Time.now();

  public func greet(name : Text) : async Text {
    let now = Time.now();
    let elapsedSeconds = (now - lastTime) / 1000_000_000;
    lastTime := now;
    return &quot;Hello, &quot; # name # &quot;!&quot; #
      &quot; I was last called &quot; # Int.toText(elapsedSeconds) # &quot; seconds ago&quot;;
   };
};</code></pre>

<p>Note: If <code>moc</code> is invoked with <code>-no-timer</code>, the importing will fail.
Note: The resolution of the timers is in the order of the block rate,</p>
<pre><code>  so durations should be chosen well above that. For frequent
  canister wake-ups the heartbeat mechanism should be considered.</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Timer.html">Timer</a><div class="index-item-comment"><p>Timers for one-off or periodic tasks. Applicable as part of the default mechanism.
If <code>moc</code> is invoked with <code>-no-timer</code>, the importing will fail. Furthermore, if passed <code>--trap-on-call-error</code>, a congested canister send queue may prevent timer expirations to execute at runtime. It may also deactivate the global timer.</p>
<pre><code>motoko name=import
import Timer &quot;mo:core/Timer&quot;;</code></pre>

<p>The resolution of the timers is similar to the block rate,
so durations should be chosen well above that. For frequent
canister wake-ups, consider using the <a href="https://internetcomputer.org/docs/current/motoko/main/writing-motoko/heartbeats">heartbeat</a> mechanism; however, when possible, canisters should prefer timers.</p>
<p>The functionality described below is enabled only when the actor does not override it by declaring an explicit <code>system func timer</code>.</p>
<p>Timers are <em>not</em> persisted across upgrades. One possible strategy
to re-establish timers after an upgrade is to use stable variables
in the <code>post_upgrade</code> hook and distill necessary timer information
from there.</p>
<p>Using timers for security (e.g., access control) is strongly discouraged.
Make sure to inform yourself about state-of-the-art dapp security.
If you must use timers for security controls, be sure
to consider reentrancy issues as well as the vanishing of timers on upgrades
and reinstalls.</p>
<p>For further usage information for timers on the IC, please consult
<a href="https://internetcomputer.org/docs/current/developer-docs/backend/periodic-tasks#timers-library-limitations">the documentation</a>.</p>
</div></li><li class="index-item"><a class="index-item-link" href="Tuples.html">Tuples</a><div class="index-item-comment"><p>Contains modules for working with tuples of different sizes.</p>
<p>Usage example:</p>
<pre class="motoko"><code class="motoko">import { Tuple2; Tuple3 } &quot;mo:core/Tuples&quot;;
import Bool &quot;mo:core/Bool&quot;;
import Nat &quot;mo:core/Nat&quot;;

let swapped = Tuple2.swap((1, &quot;hello&quot;));
assert swapped == (&quot;hello&quot;, 1);
let text = Tuple3.toText((1, true, 3), Nat.toText, Bool.toText, Nat.toText);
assert text == &quot;(1, true, 3)&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="Types.html">Types</a><div class="index-item-comment"><p>Common types used throughout the core package.</p>
<p>Example usage:</p>
<pre><code>motoko name=import
import { type Result; type Iter } &quot;mo:core/Types&quot;;

// Result for error handling
let result : Result&lt;Int, Text&gt; = #ok(42);

// Iterator for sequences
let iter : Iter&lt;Nat&gt; = { next = func() { ?1 } };</code></pre></div></li><li class="index-item"><a class="index-item-link" href="VarArray.html">VarArray</a><div class="index-item-comment"><p>Provides extended utility functions on mutable Arrays (<code>[var]</code>).</p>
<p>Note the difference between mutable (<code>[var]</code>) and immutable (<code>[]</code>) arrays.
Mutable arrays allow their elements to be modified after creation, while
immutable arrays are fixed once created.</p>
<p>WARNING: If you are looking for a list that can grow and shrink in size,
it is recommended you use <code>List</code> for those purposes.
Arrays must be created with a fixed size.</p>
<p>Import from the core package to use this module.</p>
<pre><code>motoko name=import
import VarArray &quot;mo:core/VarArray&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="WeakReference.html">WeakReference</a><div class="index-item-comment"><p>Module that implements a weak reference to an object.</p>
<p>ATTENTION: This functionality does not work with classical persistence (<code>--legacy-persistence</code> moc flag).</p>
<p>Usage example:
Import from the core package to use this module.</p>
<pre><code>motoko name=import
import WeakReference &quot;mo:core/WeakReference&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="internal/BTreeHelper.html">internal/BTreeHelper</a><div class="index-item-comment"></div></li><li class="index-item"><a class="index-item-link" href="internal/PRNG.html">internal/PRNG</a><div class="index-item-comment"><p>Collection of pseudo-random number generators</p>
<p>The algorithms deliver deterministic statistical randomness,
not cryptographic randomness.</p>
<p>Algorithm 1: 128-bit Seiran PRNG
See: https://github.com/andanteyk/prng-seiran</p>
<p>Algorithm 2: SFC64 and SFC32 (Chris Doty-Humphrey’s Small Fast Chaotic PRNG)
See: https://numpy.org/doc/stable/reference/random/bit_generators/sfc64.html</p>
<p>Copyright: 2023 MR Research AG
Main author: react0r-com
Contributors: Timo Hanke (timohanke)</p>
</div></li><li class="index-item"><a class="index-item-link" href="pure/List.html">pure/List</a><div class="index-item-comment"><p>Purely-functional, singly-linked list data structure.
This module provides immutable lists with efficient prepend and traversal operations.</p>
<p>A list of type <code>List&lt;T&gt;</code> is either <code>null</code> or an optional pair of a value of type <code>T</code> and a tail, itself of type <code>List&lt;T&gt;</code>.</p>
<p>To use this library, import it using:</p>
<pre><code>motoko name=import
import List &quot;mo:core/pure/List&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="pure/Map.html">pure/Map</a><div class="index-item-comment"><p>Immutable, ordered key-value maps.</p>
<p>The map type is stable whenever the key and value types are stable, allowing
map values to be stored in stable variables.</p>
<p>Keys are ordered by an explicit <code>compare</code> function, which <em>must</em> be the same
across all operations on a given map.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Map &quot;mo:core/pure/Map&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  // creation
  let empty = Map.empty&lt;Nat, Text&gt;();
  // insertion
  let map1 = Map.add(empty, Nat.compare, 0, &quot;Zero&quot;);
  // retrieval
  assert Map.get(empty, Nat.compare, 0) == null;
  assert Map.get(map1, Nat.compare, 0) == ?&quot;Zero&quot;;
  // removal
  let map2 = Map.remove(map1, Nat.compare, 0);
  assert not Map.isEmpty(map1);
  assert Map.isEmpty(map2);
}</code></pre>

<p>The internal representation is a red-black tree.</p>
<p>A red-black tree is a balanced binary search tree ordered by the keys.</p>
<p>The tree data structure internally colors each of its nodes either red or black,
and uses this information to balance the tree during the modifying operations.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire tree.
<code>n</code> denotes the number of key-value entries (i.e. nodes) stored in the tree.</li></ul>

<p>Note:</p>
<ul><li>Map operations, such as retrieval, insertion, and removal create <code>O(log(n))</code> temporary objects that become garbage.</li></ul>

<p>Credits:</p>
<p>The core of this implementation is derived from:</p>
<ul><li>Ken Friis Larsen's <a href="https://github.com/kfl/mosml/blob/master/src/mosmllib/Redblackmap.sml">RedBlackMap.sml</a>, which itself is based on:</li><li>Stefan Kahrs, &quot;Red-black trees with types&quot;, Journal of Functional Programming, 11(4): 425-432 (2001), <a href="http://www.cs.ukc.ac.uk/people/staff/smk/redblack/rb.html">version 1 in web appendix</a>.</li></ul></div></li><li class="index-item"><a class="index-item-link" href="pure/Queue.html">pure/Queue</a><div class="index-item-comment"><p>Double-ended queue of a generic element type <code>T</code>.</p>
<p>The interface is purely functional, not imperative, and queues are immutable values.
In particular, Queue operations such as push and pop do not update their input queue but, instead, return the
value of the modified Queue, alongside any other data.
The input queue is left unchanged.</p>
<p>Examples of use-cases:
Queue (FIFO) by using <code>pushBack()</code> and <code>popFront()</code>.
Stack (LIFO) by using <code>pushFront()</code> and <code>popFront()</code>.</p>
<p>A Queue is internally implemented as two lists, a head access list and a (reversed) tail access list,
that are dynamically size-balanced by splitting.</p>
<p>Construction: Create a new queue with the <code>empty&lt;T&gt;()</code> function.</p>
<p>Note on the costs of push and pop functions:</p>
<ul><li>Runtime: <code>O(1)</code> amortized costs, <code>O(size)</code> worst case cost per single call.</li><li>Space: <code>O(1)</code> amortized costs, <code>O(size)</code> worst case cost per single call.</li></ul>

<p><code>n</code> denotes the number of elements stored in the queue.</p>
<p>Note that some operations that traverse the elements of the queue (e.g. <code>forEach</code>, <code>values</code>) preserve the order of the elements,
whereas others (e.g. <code>map</code>, <code>contains</code>) do NOT guarantee that the elements are visited in any order.
The order is undefined to avoid allocations, making these operations more efficient.</p>
<pre><code>motoko name=import
import Queue &quot;mo:core/pure/Queue&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="pure/RealTimeQueue.html">pure/RealTimeQueue</a><div class="index-item-comment"><p>Double-ended immutable queue with guaranteed <code>O(1)</code> push/pop operations (caveat: high constant factor).
For a default immutable queue implementation, see <code>pure/Queue</code>.</p>
<p>This module provides an alternative implementation with better worst-case performance for single operations, e.g. <code>pushBack</code> and <code>popFront</code>.
These operations are always constant time, <code>O(1)</code>, which eliminates spikes in performance of <code>pure/Queue</code> operations
that are caused by the amortized nature of the <code>pure/Queue</code> implementation, which can lead to <code>O(n)</code> worst-case performance for a single operation.
The spikes in performance can cause a single message to take multiple more rounds to complete than most other messages.</p>
<p>However, the <code>O(1)</code> operations come at a cost of higher constant factor than the <code>pure/Queue</code> implementation:</p>
<ul><li>'pop' operations are on average 3x more expensive</li><li>'push' operations are on average 8x more expensive</li></ul>

<p>For better performance across multiple operations and when the spikes in single operations are not a problem, use <code>pure/Queue</code>.
For guaranteed <code>O(1)</code> operations, use <code>pure/RealTimeQueue</code>.</p>
<p><hr/>The interface is purely functional, not imperative, and queues are immutable values.
In particular, Queue operations such as push and pop do not update their input queue but, instead, return the
value of the modified Queue, alongside any other data.
The input queue is left unchanged.</p>
<p>Examples of use-cases:</p>
<ul><li>Queue (FIFO) by using <code>pushBack()</code> and <code>popFront()</code>.</li><li>Stack (LIFO) by using <code>pushFront()</code> and <code>popFront()</code>.</li><li>Deque (double-ended queue) by using any combination of push/pop operations on either end.</li></ul>

<p>A Queue is internally implemented as a real-time double-ended queue based on the paper
&quot;Real-Time Double-Ended Queue Verified (Proof Pearl)&quot;. The implementation maintains
worst-case constant time <code>O(1)</code> for push/pop operations through gradual rebalancing steps.</p>
<p>Construction: Create a new queue with the <code>empty&lt;T&gt;()</code> function.</p>
<p>Note that some operations that traverse the elements of the queue (e.g. <code>forEach</code>, <code>values</code>) preserve the order of the elements,
whereas others (e.g. <code>map</code>, <code>contains</code>) do NOT guarantee that the elements are visited in any order.
The order is undefined to avoid allocations, making these operations more efficient.</p>
<pre><code>motoko name=import
import Queue &quot;mo:core/pure/RealTimeQueue&quot;;</code></pre></div></li><li class="index-item"><a class="index-item-link" href="pure/Set.html">pure/Set</a><div class="index-item-comment"><p>Pure (immutable) sets based on order/comparison of elements.
A set is a collection of elements without duplicates.
The set data structure type is stable and can be used for orthogonal persistence.</p>
<p>Example:</p>
<pre class="motoko"><code class="motoko">import Set &quot;mo:core/pure/Set&quot;;
import Nat &quot;mo:core/Nat&quot;;

persistent actor {
  let set = Set.fromIter([3, 1, 2, 3].values(), Nat.compare);
  assert Set.size(set) == 3;
  assert not Set.contains(set, Nat.compare, 4);
  let diff = Set.difference(set, set, Nat.compare);
  assert Set.isEmpty(diff);
}</code></pre>

<p>These sets are implemented as red-black trees, a balanced binary search tree of ordered elements.</p>
<p>The tree data structure internally colors each of its nodes either red or black,
and uses this information to balance the tree during modifying operations.</p>
<p>Performance:</p>
<ul><li>Runtime: <code>O(log(n))</code> worst case cost per insertion, removal, and retrieval operation.</li><li>Space: <code>O(n)</code> for storing the entire tree.
<code>n</code> denotes the number of elements (i.e. nodes) stored in the tree.</li></ul>

<p>Credits:</p>
<p>The core of this implementation is derived from:</p>
<ul><li>Ken Friis Larsen's <a href="https://github.com/kfl/mosml/blob/master/src/mosmllib/Redblackmap.sml">RedBlackMap.sml</a>, which itself is based on:</li><li>Stefan Kahrs, &quot;Red-black trees with types&quot;, Journal of Functional Programming, 11(4): 425-432 (2001), <a href="http://www.cs.ukc.ac.uk/people/staff/smk/redblack/rb.html">version 1 in web appendix</a>.</li></ul></div></li></ul></div></html>