[
  {
    "name": "Array",
    "functions": [
      {
        "name": "all",
        "type": "<T>(array : [T], predicate : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(array : [T], predicate : T -> Bool) : Bool"
      },
      {
        "name": "chain",
        "type": "<T, Y>(array : [T], k : T -> [Y]) : [Y]"
      },
      {
        "name": "compare",
        "type": "<T>(array1 : [T], array2 : [T], compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "concat",
        "type": "<T>(array1 : [T], array2 : [T]) : [T]"
      },
      {
        "name": "empty",
        "type": "<T>() : [T]"
      },
      {
        "name": "equal",
        "type": "<T>(array1 : [T], array2 : [T], equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(array : [T], f : T -> Bool) : [T]"
      },
      {
        "name": "filterMap",
        "type": "<T, Y>(array : [T], f : T -> ?Y) : [Y]"
      },
      {
        "name": "find",
        "type": "<T>(array : [T], predicate : T -> Bool) : ?T"
      },
      {
        "name": "flatten",
        "type": "<T>(arrays : Iter.Iter<[T]>) : [T]"
      },
      {
        "name": "foldLeft",
        "type": "<T, A>(array : [T], base : A, combine : (A, T) -> A) : A"
      },
      {
        "name": "foldRight",
        "type": "<T, A>(array : [T], base : A, combine : (T, A) -> A) : A"
      },
      {
        "name": "forEach",
        "type": "<T>(array : [T], f : T -> ())"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : Iter.Iter<T>) : [T]"
      },
      {
        "name": "fromVarArray",
        "type": "<T>(varArray : [var T]) : [T]"
      },
      {
        "name": "generate",
        "type": "<T>(size : Nat, generator : Nat -> T) : [T]"
      },
      {
        "name": "indexOf",
        "type": "<T>(element : T, array : [T], equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "init",
        "type": "<T>(size : Nat, initValue : T) : [T]"
      },
      {
        "name": "isEmpty",
        "type": "<T>(array : [T]) : Bool"
      },
      {
        "name": "keys",
        "type": "<T>(array : [T]) : Iter.Iter<Nat>"
      },
      {
        "name": "lastIndexOf",
        "type": "<T>(element : T, array : [T], equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "map",
        "type": "<T, Y>(array : [T], f : T -> Y) : [Y]"
      },
      {
        "name": "mapEntries",
        "type": "<T, Y>(array : [T], f : (T, Nat) -> Y) : [Y]"
      },
      {
        "name": "mapResult",
        "type": "<T, Y, E>(array : [T], f : T -> Result.Result<Y, E>) : Result.Result<[Y], E>"
      },
      {
        "name": "nextIndexOf",
        "type": "<T>(element : T, array : [T], fromInclusive : Nat, equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "prevIndexOf",
        "type": "<T>(element : T, array : [T], fromExclusive : Nat, equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "reverse",
        "type": "<T>(array : [T]) : [T]"
      },
      {
        "name": "singleton",
        "type": "<T>(element : T) : [T]"
      },
      {
        "name": "size",
        "type": "<T>(array : [T]) : Nat"
      },
      {
        "name": "slice",
        "type": "<T>(array : [T], fromInclusive : Int, toExclusive : Int) : Iter.Iter<T>"
      },
      {
        "name": "sort",
        "type": "<T>(array : [T], compare : (T, T) -> Order.Order) : [T]"
      },
      {
        "name": "subArray",
        "type": "<T>(array : [T], start : Nat, length : Nat) : [T]"
      },
      {
        "name": "toText",
        "type": "<T>(array : [T], f : T -> Text) : Text"
      },
      {
        "name": "toVarArray",
        "type": "<T>(array : [T]) : [var T]"
      },
      {
        "name": "values",
        "type": "<T>(array : [T]) : Iter.Iter<T>"
      }
    ]
  },
  {
    "name": "Blob",
    "functions": [
      {
        "name": "compare",
        "type": "(b1 : Blob, b2 : Blob) : { #less; #equal; #greater }"
      },
      {
        "name": "empty",
        "type": "() : Blob"
      },
      {
        "name": "equal",
        "type": "(blob1 : Blob, blob2 : Blob) : Bool"
      },
      {
        "name": "fromArray",
        "type": "(bytes : [Nat8]) : Blob"
      },
      {
        "name": "fromVarArray",
        "type": "(bytes : [var Nat8]) : Blob"
      },
      {
        "name": "greater",
        "type": "(blob1 : Blob, blob2 : Blob) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(blob1 : Blob, blob2 : Blob) : Bool"
      },
      {
        "name": "hash",
        "type": "(blob : Blob) : Nat32"
      },
      {
        "name": "less",
        "type": "(blob1 : Blob, blob2 : Blob) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(blob1 : Blob, blob2 : Blob) : Bool"
      },
      {
        "name": "notEqual",
        "type": "(blob1 : Blob, blob2 : Blob) : Bool"
      },
      {
        "name": "size",
        "type": "(blob : Blob) : Nat"
      },
      {
        "name": "toArray",
        "type": "(blob : Blob) : [Nat8]"
      },
      {
        "name": "toVarArray",
        "type": "(blob : Blob) : [var Nat8]"
      }
    ]
  },
  {
    "name": "Bool",
    "functions": [
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Bool>"
      },
      {
        "name": "compare",
        "type": "(a : Bool, b : Bool) : { #less; #equal; #greater }"
      },
      {
        "name": "equal",
        "type": "(a : Bool, b : Bool) : Bool"
      },
      {
        "name": "logicalAnd",
        "type": "(a : Bool, b : Bool) : Bool"
      },
      {
        "name": "logicalNot",
        "type": "(bool : Bool) : Bool"
      },
      {
        "name": "logicalOr",
        "type": "(a : Bool, b : Bool) : Bool"
      },
      {
        "name": "logicalXor",
        "type": "(a : Bool, b : Bool) : Bool"
      },
      {
        "name": "toText",
        "type": "(bool : Bool) : Text"
      }
    ]
  },
  {
    "name": "CertifiedData",
    "functions": [
      {
        "name": "getCertificate",
        "type": ": () -> ?Blob"
      },
      {
        "name": "set",
        "type": ": (data : Blob) -> ()"
      }
    ]
  },
  {
    "name": "Char",
    "functions": [
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Char>"
      },
      {
        "name": "compare",
        "type": "(x : Char, y : Char) : { #less; #equal; #greater }"
      },
      {
        "name": "equal",
        "type": "(x : Char, y : Char) : Bool"
      },
      {
        "name": "fromNat32",
        "type": ": (w : Nat32) -> Char"
      },
      {
        "name": "greater",
        "type": "(x : Char, y : Char) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Char, y : Char) : Bool"
      },
      {
        "name": "isAlphabetic",
        "type": ": (c : Char) -> Bool"
      },
      {
        "name": "isDigit",
        "type": "(c : Char) : Bool"
      },
      {
        "name": "isLowercase",
        "type": ": (c : Char) -> Bool"
      },
      {
        "name": "isUppercase",
        "type": ": (c : Char) -> Bool"
      },
      {
        "name": "isWhitespace",
        "type": ": (c : Char) -> Bool"
      },
      {
        "name": "less",
        "type": "(x : Char, y : Char) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Char, y : Char) : Bool"
      },
      {
        "name": "notEqual",
        "type": "(x : Char, y : Char) : Bool"
      },
      {
        "name": "toNat32",
        "type": ": (c : Char) -> Nat32"
      },
      {
        "name": "toText",
        "type": ": (c : Char) -> Text"
      }
    ]
  },
  {
    "name": "Cycles",
    "functions": [
      {
        "name": "accept",
        "type": ": <system>(amount : Nat) -> (accepted : Nat)"
      },
      {
        "name": "add",
        "type": ": <system>(amount : Nat) -> ()"
      },
      {
        "name": "available",
        "type": ": () -> (amount : Nat)"
      },
      {
        "name": "balance",
        "type": ": () -> (amount : Nat)"
      },
      {
        "name": "main",
        "type": "() : async()"
      },
      {
        "name": "main",
        "type": "() : async()"
      },
      {
        "name": "main",
        "type": "() : async()"
      },
      {
        "name": "main",
        "type": "() : async()"
      },
      {
        "name": "main",
        "type": "() : async()"
      },
      {
        "name": "main",
        "type": "() : async()"
      },
      {
        "name": "refunded",
        "type": ": () -> (amount : Nat)"
      }
    ]
  },
  {
    "name": "Debug",
    "functions": [
      {
        "name": "print",
        "type": "(text : Text)"
      },
      {
        "name": "todo",
        "type": "() : None"
      }
    ]
  },
  {
    "name": "Error",
    "functions": [
      {
        "name": "code",
        "type": ": (error : Error) -> ErrorCode"
      },
      {
        "name": "message",
        "type": ": (error : Error) -> Text"
      },
      {
        "name": "reject",
        "type": ": (message : Text) -> Error"
      }
    ]
  },
  {
    "name": "Float",
    "functions": [
      {
        "name": "abs",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "add",
        "type": "(x : Float, y : Float) : Float"
      },
      {
        "name": "arccos",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "arcsin",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "arctan",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "arctan2",
        "type": ": (y : Float, x : Float) -> Float"
      },
      {
        "name": "ceil",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "compare",
        "type": "(x : Float, y : Float) : { #less; #equal; #greater }"
      },
      {
        "name": "copySign",
        "type": ": (x : Float, y : Float) -> Float"
      },
      {
        "name": "cos",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "div",
        "type": "(x : Float, y : Float) : Float"
      },
      {
        "name": "e",
        "type": ": Float"
      },
      {
        "name": "equal",
        "type": "(x : Float, y : Float) : Bool"
      },
      {
        "name": "equalWithin",
        "type": "(x : Float, y : Float, epsilon : Float) : Bool"
      },
      {
        "name": "exp",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "floor",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "format",
        "type": "(fmt : { #fix : Nat8; #exp : Nat8; #gen : Nat8; #exact }, x : Float) : Text"
      },
      {
        "name": "fromInt",
        "type": ": Int -> Float"
      },
      {
        "name": "fromInt64",
        "type": ": Int64 -> Float"
      },
      {
        "name": "greater",
        "type": "(x : Float, y : Float) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Float, y : Float) : Bool"
      },
      {
        "name": "isNaN",
        "type": "(number : Float) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Float, y : Float) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Float, y : Float) : Bool"
      },
      {
        "name": "log",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "max",
        "type": ": (x : Float, y : Float) -> Float"
      },
      {
        "name": "min",
        "type": ": (x : Float, y : Float) -> Float"
      },
      {
        "name": "mul",
        "type": "(x : Float, y : Float) : Float"
      },
      {
        "name": "nearest",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "neg",
        "type": "(x : Float) : Float"
      },
      {
        "name": "notEqual",
        "type": "(x : Float, y : Float) : Bool"
      },
      {
        "name": "notEqualWithin",
        "type": "(x : Float, y : Float, epsilon : Float) : Bool"
      },
      {
        "name": "pi",
        "type": ": Float"
      },
      {
        "name": "pow",
        "type": "(x : Float, y : Float) : Float"
      },
      {
        "name": "rem",
        "type": "(x : Float, y : Float) : Float"
      },
      {
        "name": "sin",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "sqrt",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "sub",
        "type": "(x : Float, y : Float) : Float"
      },
      {
        "name": "tan",
        "type": ": (x : Float) -> Float"
      },
      {
        "name": "toInt",
        "type": ": Float -> Int"
      },
      {
        "name": "toInt64",
        "type": ": Float -> Int64"
      },
      {
        "name": "toText",
        "type": ": Float -> Text"
      },
      {
        "name": "trunc",
        "type": ": (x : Float) -> Float"
      }
    ]
  },
  {
    "name": "Func",
    "functions": [
      {
        "name": "compose",
        "type": "<A, B, C>(f : B -> C, g : A -> B) : A -> C"
      },
      {
        "name": "const",
        "type": "<A, B>(x : A) : B -> A"
      },
      {
        "name": "identity",
        "type": "<A>(x : A) : A"
      }
    ]
  },
  {
    "name": "Hash",
    "functions": [
      {
        "name": "bit",
        "type": "(h : Hash, pos : Nat) : Bool"
      },
      {
        "name": "equal",
        "type": "(ha : Hash, hb : Hash) : Bool"
      },
      {
        "name": "hash",
        "type": "(n : Nat) : Hash"
      },
      {
        "name": "length",
        "type": ": Nat"
      }
    ]
  },
  {
    "name": "Int",
    "functions": [
      {
        "name": "abs",
        "type": "(x : Int) : Nat"
      },
      {
        "name": "add",
        "type": "(x : Int, y : Int) : Int"
      },
      {
        "name": "compare",
        "type": "(x : Int, y : Int) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Int, y : Int) : Int"
      },
      {
        "name": "equal",
        "type": "(x : Int, y : Int) : Bool"
      },
      {
        "name": "greater",
        "type": "(x : Int, y : Int) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Int, y : Int) : Bool"
      },
      {
        "name": "hash",
        "type": "(i : Int) : Hash.Hash"
      },
      {
        "name": "hashAcc",
        "type": "(h1 : Hash.Hash, i : Int) : Hash.Hash"
      },
      {
        "name": "less",
        "type": "(x : Int, y : Int) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Int, y : Int) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Int, y : Int) : Int"
      },
      {
        "name": "min",
        "type": "(x : Int, y : Int) : Int"
      },
      {
        "name": "mul",
        "type": "(x : Int, y : Int) : Int"
      },
      {
        "name": "neg",
        "type": "(x : Int) : Int"
      },
      {
        "name": "notEqual",
        "type": "(x : Int, y : Int) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Int, y : Int) : Int"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Int, toExclusive : Int) : Iter.Iter<Int>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Int, to : Int) : Iter.Iter<Int>"
      },
      {
        "name": "rem",
        "type": "(x : Int, y : Int) : Int"
      },
      {
        "name": "sub",
        "type": "(x : Int, y : Int) : Int"
      },
      {
        "name": "toText",
        "type": "(x : Int) : Text"
      }
    ]
  },
  {
    "name": "Int16",
    "functions": [
      {
        "name": "abs",
        "type": "(x : Int16) : Int16"
      },
      {
        "name": "add",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "addWrap",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Int16>"
      },
      {
        "name": "bitand",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "bitclear",
        "type": "(x : Int16, p : Nat) : Int16"
      },
      {
        "name": "bitcountLeadingZero",
        "type": ": (x : Int16) -> Int16"
      },
      {
        "name": "bitcountNonZero",
        "type": ": (x : Int16) -> Int16"
      },
      {
        "name": "bitcountTrailingZero",
        "type": ": (x : Int16) -> Int16"
      },
      {
        "name": "bitflip",
        "type": "(x : Int16, p : Nat) : Int16"
      },
      {
        "name": "bitnot",
        "type": "(x : Int16) : Int16"
      },
      {
        "name": "bitor",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "bitrotLeft",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "bitrotRight",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "bitset",
        "type": "(x : Int16, p : Nat) : Int16"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "bittest",
        "type": "(x : Int16, p : Nat) : Bool"
      },
      {
        "name": "bitxor",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "compare",
        "type": "(x : Int16, y : Int16) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "equal",
        "type": "(x : Int16, y : Int16) : Bool"
      },
      {
        "name": "fromInt",
        "type": ": Int -> Int16"
      },
      {
        "name": "fromInt32",
        "type": ": Int32 -> Int16"
      },
      {
        "name": "fromInt8",
        "type": ": Int8 -> Int16"
      },
      {
        "name": "fromIntWrap",
        "type": ": Int -> Int16"
      },
      {
        "name": "fromNat16",
        "type": ": Nat16 -> Int16"
      },
      {
        "name": "greater",
        "type": "(x : Int16, y : Int16) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Int16, y : Int16) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Int16, y : Int16) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Int16, y : Int16) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "maxValue",
        "type": ": Int16"
      },
      {
        "name": "min",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "minValue",
        "type": ": Int16"
      },
      {
        "name": "mul",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "mulWrap",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "neg",
        "type": "(x : Int16) : Int16"
      },
      {
        "name": "notEqual",
        "type": "(x : Int16, y : Int16) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "powWrap",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Int16, toExclusive : Int16) : Iter.Iter<Int16>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Int16, to : Int16) : Iter.Iter<Int16>"
      },
      {
        "name": "rem",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "sub",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "subWrap",
        "type": "(x : Int16, y : Int16) : Int16"
      },
      {
        "name": "toInt",
        "type": ": Int16 -> Int"
      },
      {
        "name": "toInt32",
        "type": ": Int16 -> Int32"
      },
      {
        "name": "toInt8",
        "type": ": Int16 -> Int8"
      },
      {
        "name": "toNat16",
        "type": ": Int16 -> Nat16"
      },
      {
        "name": "toText",
        "type": "(x : Int16) : Text"
      }
    ]
  },
  {
    "name": "Int32",
    "functions": [
      {
        "name": "abs",
        "type": "(x : Int32) : Int32"
      },
      {
        "name": "add",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "addWrap",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Int32>"
      },
      {
        "name": "bitand",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "bitclear",
        "type": "(x : Int32, p : Nat) : Int32"
      },
      {
        "name": "bitcountLeadingZero",
        "type": ": (x : Int32) -> Int32"
      },
      {
        "name": "bitcountNonZero",
        "type": ": (x : Int32) -> Int32"
      },
      {
        "name": "bitcountTrailingZero",
        "type": ": (x : Int32) -> Int32"
      },
      {
        "name": "bitflip",
        "type": "(x : Int32, p : Nat) : Int32"
      },
      {
        "name": "bitnot",
        "type": "(x : Int32) : Int32"
      },
      {
        "name": "bitor",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "bitrotLeft",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "bitrotRight",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "bitset",
        "type": "(x : Int32, p : Nat) : Int32"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "bittest",
        "type": "(x : Int32, p : Nat) : Bool"
      },
      {
        "name": "bitxor",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "compare",
        "type": "(x : Int32, y : Int32) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "equal",
        "type": "(x : Int32, y : Int32) : Bool"
      },
      {
        "name": "fromInt",
        "type": ": Int -> Int32"
      },
      {
        "name": "fromInt16",
        "type": ": Int16 -> Int32"
      },
      {
        "name": "fromInt64",
        "type": ": Int64 -> Int32"
      },
      {
        "name": "fromIntWrap",
        "type": ": Int -> Int32"
      },
      {
        "name": "fromNat32",
        "type": ": Nat32 -> Int32"
      },
      {
        "name": "greater",
        "type": "(x : Int32, y : Int32) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Int32, y : Int32) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Int32, y : Int32) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Int32, y : Int32) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "maxValue",
        "type": ": Int32"
      },
      {
        "name": "min",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "minValue",
        "type": ": Int32"
      },
      {
        "name": "mul",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "mulWrap",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "neg",
        "type": "(x : Int32) : Int32"
      },
      {
        "name": "notEqual",
        "type": "(x : Int32, y : Int32) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "powWrap",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Int32, toExclusive : Int32) : Iter.Iter<Int32>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Int32, to : Int32) : Iter.Iter<Int32>"
      },
      {
        "name": "rem",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "sub",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "subWrap",
        "type": "(x : Int32, y : Int32) : Int32"
      },
      {
        "name": "toInt",
        "type": ": Int32 -> Int"
      },
      {
        "name": "toInt16",
        "type": ": Int32 -> Int16"
      },
      {
        "name": "toInt64",
        "type": ": Int32 -> Int64"
      },
      {
        "name": "toNat32",
        "type": ": Int32 -> Nat32"
      },
      {
        "name": "toText",
        "type": "(x : Int32) : Text"
      }
    ]
  },
  {
    "name": "Int64",
    "functions": [
      {
        "name": "abs",
        "type": "(x : Int64) : Int64"
      },
      {
        "name": "add",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "addWrap",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Int64>"
      },
      {
        "name": "bitand",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "bitclear",
        "type": "(x : Int64, p : Nat) : Int64"
      },
      {
        "name": "bitcountLeadingZero",
        "type": ": (x : Int64) -> Int64"
      },
      {
        "name": "bitcountNonZero",
        "type": ": (x : Int64) -> Int64"
      },
      {
        "name": "bitcountTrailingZero",
        "type": ": (x : Int64) -> Int64"
      },
      {
        "name": "bitflip",
        "type": "(x : Int64, p : Nat) : Int64"
      },
      {
        "name": "bitnot",
        "type": "(x : Int64) : Int64"
      },
      {
        "name": "bitor",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "bitrotLeft",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "bitrotRight",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "bitset",
        "type": "(x : Int64, p : Nat) : Int64"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "bittest",
        "type": "(x : Int64, p : Nat) : Bool"
      },
      {
        "name": "bitxor",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "compare",
        "type": "(x : Int64, y : Int64) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "equal",
        "type": "(x : Int64, y : Int64) : Bool"
      },
      {
        "name": "fromInt",
        "type": ": Int -> Int64"
      },
      {
        "name": "fromInt32",
        "type": ": Int32 -> Int64"
      },
      {
        "name": "fromIntWrap",
        "type": ": Int -> Int64"
      },
      {
        "name": "fromNat64",
        "type": ": Nat64 -> Int64"
      },
      {
        "name": "greater",
        "type": "(x : Int64, y : Int64) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Int64, y : Int64) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Int64, y : Int64) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Int64, y : Int64) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "maxValue",
        "type": ": Int64"
      },
      {
        "name": "min",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "minValue",
        "type": ": Int64"
      },
      {
        "name": "mul",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "mulWrap",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "neg",
        "type": "(x : Int64) : Int64"
      },
      {
        "name": "notEqual",
        "type": "(x : Int64, y : Int64) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "powWrap",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Int64, toExclusive : Int64) : Iter.Iter<Int64>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Int64, to : Int64) : Iter.Iter<Int64>"
      },
      {
        "name": "rem",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "sub",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "subWrap",
        "type": "(x : Int64, y : Int64) : Int64"
      },
      {
        "name": "toInt",
        "type": ": Int64 -> Int"
      },
      {
        "name": "toInt32",
        "type": ": Int64 -> Int32"
      },
      {
        "name": "toNat64",
        "type": ": Int64 -> Nat64"
      },
      {
        "name": "toText",
        "type": "(x : Int64) : Text"
      }
    ]
  },
  {
    "name": "Int8",
    "functions": [
      {
        "name": "abs",
        "type": "(x : Int8) : Int8"
      },
      {
        "name": "add",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "addWrap",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Int8>"
      },
      {
        "name": "bitand",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "bitclear",
        "type": "(x : Int8, p : Nat) : Int8"
      },
      {
        "name": "bitcountLeadingZero",
        "type": ": (x : Int8) -> Int8"
      },
      {
        "name": "bitcountNonZero",
        "type": ": (x : Int8) -> Int8"
      },
      {
        "name": "bitcountTrailingZero",
        "type": ": (x : Int8) -> Int8"
      },
      {
        "name": "bitflip",
        "type": "(x : Int8, p : Nat) : Int8"
      },
      {
        "name": "bitnot",
        "type": "(x : Int8) : Int8"
      },
      {
        "name": "bitor",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "bitrotLeft",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "bitrotRight",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "bitset",
        "type": "(x : Int8, p : Nat) : Int8"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "bittest",
        "type": "(x : Int8, p : Nat) : Bool"
      },
      {
        "name": "bitxor",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "compare",
        "type": "(x : Int8, y : Int8) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "equal",
        "type": "(x : Int8, y : Int8) : Bool"
      },
      {
        "name": "fromInt",
        "type": ": Int -> Int8"
      },
      {
        "name": "fromInt16",
        "type": ": Int16 -> Int8"
      },
      {
        "name": "fromIntWrap",
        "type": ": Int -> Int8"
      },
      {
        "name": "fromNat8",
        "type": ": Nat8 -> Int8"
      },
      {
        "name": "greater",
        "type": "(x : Int8, y : Int8) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Int8, y : Int8) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Int8, y : Int8) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Int8, y : Int8) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "maxValue",
        "type": ": Int8"
      },
      {
        "name": "min",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "minValue",
        "type": ": Int8"
      },
      {
        "name": "mul",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "mulWrap",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "neg",
        "type": "(x : Int8) : Int8"
      },
      {
        "name": "notEqual",
        "type": "(x : Int8, y : Int8) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "powWrap",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Int8, toExclusive : Int8) : Iter.Iter<Int8>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Int8, to : Int8) : Iter.Iter<Int8>"
      },
      {
        "name": "rem",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "sub",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "subWrap",
        "type": "(x : Int8, y : Int8) : Int8"
      },
      {
        "name": "toInt",
        "type": ": Int8 -> Int"
      },
      {
        "name": "toInt16",
        "type": ": Int8 -> Int16"
      },
      {
        "name": "toNat8",
        "type": ": Int8 -> Nat8"
      },
      {
        "name": "toText",
        "type": "(x : Int8) : Text"
      }
    ]
  },
  {
    "name": "InternetComputer",
    "functions": [
      {
        "name": "call",
        "type": ": (canister : Principal, name : Text, data : Blob) -> async (reply : Blob)"
      },
      {
        "name": "countInstructions",
        "type": "(comp : () -> ()) : Nat64"
      },
      {
        "name": "performanceCounter",
        "type": ": (counter : Nat32) -> (value : Nat64)"
      },
      {
        "name": "replyDeadline",
        "type": "() : Nat"
      }
    ]
  },
  {
    "name": "Iter",
    "functions": [
      {
        "name": "concat",
        "type": "<A>(a : Iter<A>, b : Iter<A>) : Iter<A>"
      },
      {
        "name": "filter",
        "type": "<A>(xs : Iter<A>, f : A -> Bool) : Iter<A>"
      },
      {
        "name": "fromArray",
        "type": "<A>(xs : [A]) : Iter<A>"
      },
      {
        "name": "fromArrayMut",
        "type": "<A>(xs : [var A]) : Iter<A>"
      },
      {
        "name": "iterate",
        "type": "<A>( xs : Iter<A>, f : (A, Nat) -> () )"
      },
      {
        "name": "make",
        "type": "<A>(x : A) : Iter<A>"
      },
      {
        "name": "map",
        "type": "<A, B>(xs : Iter<A>, f : A -> B) : Iter<B>"
      },
      {
        "name": "next",
        "type": "() : ?B"
      },
      {
        "name": "next",
        "type": "() : ?A"
      },
      {
        "name": "next",
        "type": "() : ?A"
      },
      {
        "name": "next",
        "type": "() : ?A"
      },
      {
        "name": "next",
        "type": "() : ?A"
      },
      {
        "name": "size",
        "type": "<A>(xs : Iter<A>) : Nat"
      },
      {
        "name": "sort",
        "type": "<A>(xs : Iter<A>, compare : (A, A) -> Order.Order) : Iter<A>"
      },
      {
        "name": "toArray",
        "type": "<A>(xs : Iter<A>) : [A]"
      },
      {
        "name": "toVarArray",
        "type": "<A>(xs : Iter<A>) : [var A]"
      }
    ]
  },
  {
    "name": "IterType",
    "functions": []
  },
  {
    "name": "List",
    "functions": [
      {
        "name": "add",
        "type": "<T>(list : List<T>, item : T) : ()"
      },
      {
        "name": "all",
        "type": "<T>(list : List<T>, predicate : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(list : List<T>, predicate : T -> Bool) : Bool"
      },
      {
        "name": "binarySearch",
        "type": "<T>(list : List<T>, compare : (T, T) -> Order.Order, element : T) : ?Nat"
      },
      {
        "name": "chunk",
        "type": "<T>(list : List<T>, size : Nat) : List<List<T>>"
      },
      {
        "name": "clone",
        "type": "<T>(list : List<T>) : List<T>"
      },
      {
        "name": "compare",
        "type": "<T>(list1 : List<T>, list2 : List<T>, compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "contains",
        "type": "<T>(list : List<T>, element : T, equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "containsAll",
        "type": "<T>(list : List<T>, subList : List<T>, equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "distinct",
        "type": "<T>(list : List<T>, equal : (T, T) -> Bool) : List<T>"
      },
      {
        "name": "empty",
        "type": "<T>() : List<T>"
      },
      {
        "name": "equal",
        "type": "<T>(list1 : List<T>, list2 : List<T>, equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(list : List<T>, predicate : T -> Bool) : List<T>"
      },
      {
        "name": "filterMap",
        "type": "<T1, T2>(list : List<T1>, f : T1 -> ?T2) : List<T2>"
      },
      {
        "name": "first",
        "type": "<T>(list : List<T>) : T"
      },
      {
        "name": "flatMap",
        "type": "<T1, T2>(list : List<T1>, k : T1 -> Iter.Iter<T2>) : List<T2>"
      },
      {
        "name": "flatten",
        "type": "<T>(lists : Iter.Iter<List<T>>) : List<T>"
      },
      {
        "name": "foldLeft",
        "type": "<A, T>(list : List<T>, base : A, combine : (A, T) -> A) : A"
      },
      {
        "name": "foldRight",
        "type": "<T, A>(list : List<T>, base : A, combine : (T, A) -> A) : A"
      },
      {
        "name": "forEach",
        "type": "<T>(list : List<T>, f : T -> ())"
      },
      {
        "name": "fromArray",
        "type": "<T>(array : [T]) : List<T>"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : { next : () -> ?T }) : List<T>"
      },
      {
        "name": "fromVarArray",
        "type": "<T>(array : [var T]) : List<T>"
      },
      {
        "name": "hash",
        "type": "<T>(list : List<T>, hash : T -> Nat32) : Nat32"
      },
      {
        "name": "indexOf",
        "type": "<T>(list : List<T>, element : T, equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "indexOfList",
        "type": "<T>(list : List<T>, subList : List<T>, equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "isEmpty",
        "type": "(list : List<Any>) : Bool"
      },
      {
        "name": "isPrefixOf",
        "type": "<T>(list : List<T>, prefix : List<T>, equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "isSuffixOf",
        "type": "<T>(list : List<T>, suffix : List<T>, equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "last",
        "type": "<T>(list : List<T>) : T"
      },
      {
        "name": "lastIndexOf",
        "type": "<T>(list : List<T>, element : T, equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "map",
        "type": "<T1, T2>(list : List<T1>, f : T1 -> T2) : List<T2>"
      },
      {
        "name": "mapEntries",
        "type": "<T1, T2>(list : List<T1>, f : (Nat, T1) -> T2) : List<T2>"
      },
      {
        "name": "mapResult",
        "type": "<T, R, E>(list : List<T>, f : T -> Result.Result<R, E>) : Result.Result<List<R>, E>"
      },
      {
        "name": "max",
        "type": "<T>(list : List<T>, compare : (T, T) -> Order.Order) : ?T"
      },
      {
        "name": "merge",
        "type": "<T>(list1 : List<T>, list2 : List<T>, compare : (T, T) -> Order.Order) : List<T>"
      },
      {
        "name": "min",
        "type": "<T>(list : List<T>, compare : (T, T) -> Order.Order) : ?T"
      },
      {
        "name": "partition",
        "type": "<T>(list : List<T>, predicate : T -> Bool) : (List<T>, List<T>)"
      },
      {
        "name": "prefix",
        "type": "<T>(list : List<T>, length : Nat) : List<T>"
      },
      {
        "name": "put",
        "type": "<T>(list : List<T>, index : Nat, item : T) : ()"
      },
      {
        "name": "removeLast",
        "type": "<T>(list : List<T>) : ?T"
      },
      {
        "name": "reverse",
        "type": "<T>(list : List<T>)"
      },
      {
        "name": "singleton",
        "type": "<T>(element : T) : List<T>"
      },
      {
        "name": "size",
        "type": "(list : List<Any>) : Bool"
      },
      {
        "name": "split",
        "type": "<T>(list : List<T>, index : Nat) : (List<T>, List<T>)"
      },
      {
        "name": "subList",
        "type": "<T>(list : List<T>, start : Nat, length : Nat) : List<T>"
      },
      {
        "name": "suffix",
        "type": "<T>(list : List<T>, length : Nat) : List<T>"
      },
      {
        "name": "toArray",
        "type": "<T>(list : List<T>) : [T]"
      },
      {
        "name": "toText",
        "type": "<T>(list : List<T>, f : T -> Text) : Text"
      },
      {
        "name": "toVarArray",
        "type": "<T>(list : List<T>) : [var T]"
      },
      {
        "name": "values",
        "type": "<T>(list : List<T>) : Iter.Iter<T>"
      },
      {
        "name": "zip",
        "type": "<T1, T2>(list1 : List<T1>, list2 : List<T2>) : List<(T1, T2)>"
      },
      {
        "name": "zipWith",
        "type": "<T1, T2, Z>(list1 : List<T1>, list2 : List<T2>, zip : (T1, T2) -> Z) : List<Z>"
      }
    ]
  },
  {
    "name": "Map",
    "functions": [
      {
        "name": "add",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K, value : V) : ()"
      },
      {
        "name": "all",
        "type": "<K, V>(map : Map<K, V>, pred : (K, V) -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<K, V>(map : Map<K, V>, pred : (K, V) -> Bool) : Bool"
      },
      {
        "name": "assertValid",
        "type": "<K>(map : Map<K, Any>, compare : (K, K) -> Order.Order) : ()"
      },
      {
        "name": "clone",
        "type": "<K, V>(map : Map<K, V>) : Map<K, V>"
      },
      {
        "name": "compare",
        "type": "<K, V>(map1 : Map<K, V>, map2 : Map<K, V>, compareKey : (K, K) -> Order.Order, compareValue : (V, V) -> Order.Order) : Order.Order"
      },
      {
        "name": "containsKey",
        "type": "<K>(map : Map<K, Any>, compare : (K, K) -> Order.Order, key : K) : Bool"
      },
      {
        "name": "delete",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K) : ()"
      },
      {
        "name": "empty",
        "type": "<K, V>() : Map<K, V>"
      },
      {
        "name": "entries",
        "type": "<K, V>(map : Map<K, V>) : Iter.Iter<(K, V)>"
      },
      {
        "name": "equal",
        "type": "<K, V>(map1 : Map<K, V>, map2 : Map<K, V>) : Bool"
      },
      {
        "name": "filter",
        "type": "<K, V>(map : Map<K, V>, f : (K, V) -> Bool) : Map<K, V>"
      },
      {
        "name": "filterMap",
        "type": "<K, V1, V2>(map : Map<K, V1>, f : (K, V1) -> ?V2) : Map<K, V2>"
      },
      {
        "name": "foldLeft",
        "type": "<K, V, A>( map : Map<K, V>, base : A, combine : (A, K, V) -> A ) : A"
      },
      {
        "name": "foldRight",
        "type": "<K, V, A>( map : Map<K, V>, base : A, combine : (K, V, A) -> A ) : A"
      },
      {
        "name": "forEach",
        "type": "<K, V>(map : Map<K, V>, f : (K, V) -> ())"
      },
      {
        "name": "freeze",
        "type": "<K, V>(map : Map<K, V>) : Immutable.Map<K, V>"
      },
      {
        "name": "fromIter",
        "type": "<K, V>(iter : Iter.Iter<(K, V)>, compare : (K, K) -> Order.Order) : Map<K, V>"
      },
      {
        "name": "get",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K) : ?V"
      },
      {
        "name": "isEmpty",
        "type": "(map : Map<Any, Any>) : Bool"
      },
      {
        "name": "keys",
        "type": "<K>(map : Map<K, Any>) : Iter.Iter<K>"
      },
      {
        "name": "map",
        "type": "<K, V1, V2>(map : Map<K, V1>, f : (K, V1) -> V2) : Map<K, V2>"
      },
      {
        "name": "maxEntry",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order) : ?(K, V)"
      },
      {
        "name": "minEntry",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order) : ?(K, V)"
      },
      {
        "name": "put",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K, value : V) : ?V"
      },
      {
        "name": "replaceIfExists",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K, value : V) : ?V"
      },
      {
        "name": "reverseEntries",
        "type": "<K, V>(map : Map<K, V>) : Iter.Iter<(K, V)>"
      },
      {
        "name": "singleton",
        "type": "<K, V>(key : K, value : V) : Map<K, V>"
      },
      {
        "name": "size",
        "type": "(map : Map<Any, Any>) : Nat"
      },
      {
        "name": "thaw",
        "type": "<K, V>(map : Immutable.Map<K, V>) : Map<K, V>"
      },
      {
        "name": "toText",
        "type": "<K, V>(map : Map<K, V>, kf : K -> Text, vf : V -> Text) : Text"
      },
      {
        "name": "values",
        "type": "<V>(map : Map<Any, V>) : Iter.Iter<V>"
      }
    ]
  },
  {
    "name": "Nat",
    "functions": [
      {
        "name": "add",
        "type": "(x : Nat, y : Nat) : Nat"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Nat>"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Nat, y : Nat32) : Nat"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Nat, y : Nat32) : Nat"
      },
      {
        "name": "compare",
        "type": "(x : Nat, y : Nat) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Nat, y : Nat) : Nat"
      },
      {
        "name": "equal",
        "type": "(x : Nat, y : Nat) : Bool"
      },
      {
        "name": "fromText",
        "type": "(text : Text) : ?Nat"
      },
      {
        "name": "greater",
        "type": "(x : Nat, y : Nat) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Nat, y : Nat) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Nat, y : Nat) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Nat, y : Nat) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Nat, y : Nat) : Nat"
      },
      {
        "name": "min",
        "type": "(x : Nat, y : Nat) : Nat"
      },
      {
        "name": "mul",
        "type": "(x : Nat, y : Nat) : Nat"
      },
      {
        "name": "notEqual",
        "type": "(x : Nat, y : Nat) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Nat, y : Nat) : Nat"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Nat, toExclusive : Nat) : Iter.Iter<Nat>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Nat, to : Nat) : Iter.Iter<Nat>"
      },
      {
        "name": "rem",
        "type": "(x : Nat, y : Nat) : Nat"
      },
      {
        "name": "sub",
        "type": "(x : Nat, y : Nat) : Nat"
      },
      {
        "name": "toText",
        "type": "(n : Nat) : Text"
      }
    ]
  },
  {
    "name": "Nat16",
    "functions": [
      {
        "name": "add",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "addWrap",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Nat16>"
      },
      {
        "name": "bitand",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "bitclear",
        "type": "(x : Nat16, p : Nat) : Nat16"
      },
      {
        "name": "bitcountLeadingZero",
        "type": ": (x : Nat16) -> Nat16"
      },
      {
        "name": "bitcountNonZero",
        "type": ": (x : Nat16) -> Nat16"
      },
      {
        "name": "bitcountTrailingZero",
        "type": ": (x : Nat16) -> Nat16"
      },
      {
        "name": "bitflip",
        "type": "(x : Nat16, p : Nat) : Nat16"
      },
      {
        "name": "bitnot",
        "type": "(x : Nat16) : Nat16"
      },
      {
        "name": "bitor",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "bitrotLeft",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "bitrotRight",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "bitset",
        "type": "(x : Nat16, p : Nat) : Nat16"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "bittest",
        "type": "(x : Nat16, p : Nat) : Bool"
      },
      {
        "name": "bitxor",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "compare",
        "type": "(x : Nat16, y : Nat16) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "equal",
        "type": "(x : Nat16, y : Nat16) : Bool"
      },
      {
        "name": "fromIntWrap",
        "type": ": Int -> Nat16"
      },
      {
        "name": "fromNat",
        "type": ": Nat -> Nat16"
      },
      {
        "name": "fromNat32",
        "type": "(x : Nat32) : Nat16"
      },
      {
        "name": "fromNat8",
        "type": "(x : Nat8) : Nat16"
      },
      {
        "name": "greater",
        "type": "(x : Nat16, y : Nat16) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Nat16, y : Nat16) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Nat16, y : Nat16) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Nat16, y : Nat16) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "maxValue",
        "type": ": Nat16"
      },
      {
        "name": "min",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "mul",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "mulWrap",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "notEqual",
        "type": "(x : Nat16, y : Nat16) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "powWrap",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Nat16, toExclusive : Nat16) : Iter.Iter<Nat16>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Nat16, to : Nat16) : Iter.Iter<Nat16>"
      },
      {
        "name": "rem",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "sub",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "subWrap",
        "type": "(x : Nat16, y : Nat16) : Nat16"
      },
      {
        "name": "toNat",
        "type": ": Nat16 -> Nat"
      },
      {
        "name": "toNat32",
        "type": "(x : Nat16) : Nat32"
      },
      {
        "name": "toNat8",
        "type": "(x : Nat16) : Nat8"
      },
      {
        "name": "toText",
        "type": "(x : Nat16) : Text"
      }
    ]
  },
  {
    "name": "Nat32",
    "functions": [
      {
        "name": "add",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "addWrap",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Nat32>"
      },
      {
        "name": "bitand",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "bitclear",
        "type": "(x : Nat32, p : Nat) : Nat32"
      },
      {
        "name": "bitcountLeadingZero",
        "type": ": (x : Nat32) -> Nat32"
      },
      {
        "name": "bitcountNonZero",
        "type": ": (x : Nat32) -> Nat32"
      },
      {
        "name": "bitcountTrailingZero",
        "type": ": (x : Nat32) -> Nat32"
      },
      {
        "name": "bitflip",
        "type": "(x : Nat32, p : Nat) : Nat32"
      },
      {
        "name": "bitnot",
        "type": "(x : Nat32) : Nat32"
      },
      {
        "name": "bitor",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "bitrotLeft",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "bitrotRight",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "bitset",
        "type": "(x : Nat32, p : Nat) : Nat32"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "bittest",
        "type": "(x : Nat32, p : Nat) : Bool"
      },
      {
        "name": "bitxor",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "compare",
        "type": "(x : Nat32, y : Nat32) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "equal",
        "type": "(x : Nat32, y : Nat32) : Bool"
      },
      {
        "name": "fromIntWrap",
        "type": ": Int -> Nat32"
      },
      {
        "name": "fromNat",
        "type": ": Nat -> Nat32"
      },
      {
        "name": "fromNat16",
        "type": "(x : Nat16) : Nat32"
      },
      {
        "name": "fromNat64",
        "type": "(x : Nat64) : Nat32"
      },
      {
        "name": "greater",
        "type": "(x : Nat32, y : Nat32) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Nat32, y : Nat32) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Nat32, y : Nat32) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Nat32, y : Nat32) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "maxValue",
        "type": ": Nat32"
      },
      {
        "name": "min",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "mul",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "mulWrap",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "notEqual",
        "type": "(x : Nat32, y : Nat32) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "powWrap",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Nat32, toExclusive : Nat32) : Iter.Iter<Nat32>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Nat32, to : Nat32) : Iter.Iter<Nat32>"
      },
      {
        "name": "rem",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "sub",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "subWrap",
        "type": "(x : Nat32, y : Nat32) : Nat32"
      },
      {
        "name": "toNat",
        "type": ": Nat32 -> Nat"
      },
      {
        "name": "toNat16",
        "type": "(x : Nat32) : Nat16"
      },
      {
        "name": "toNat64",
        "type": "(x : Nat32) : Nat64"
      },
      {
        "name": "toText",
        "type": "(x : Nat32) : Text"
      }
    ]
  },
  {
    "name": "Nat64",
    "functions": [
      {
        "name": "add",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "addWrap",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Nat64>"
      },
      {
        "name": "bitand",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "bitclear",
        "type": "(x : Nat64, p : Nat) : Nat64"
      },
      {
        "name": "bitcountLeadingZero",
        "type": ": (x : Nat64) -> Nat64"
      },
      {
        "name": "bitcountNonZero",
        "type": ": (x : Nat64) -> Nat64"
      },
      {
        "name": "bitcountTrailingZero",
        "type": ": (x : Nat64) -> Nat64"
      },
      {
        "name": "bitflip",
        "type": "(x : Nat64, p : Nat) : Nat64"
      },
      {
        "name": "bitnot",
        "type": "(x : Nat64) : Nat64"
      },
      {
        "name": "bitor",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "bitrotLeft",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "bitrotRight",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "bitset",
        "type": "(x : Nat64, p : Nat) : Nat64"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "bittest",
        "type": "(x : Nat64, p : Nat) : Bool"
      },
      {
        "name": "bitxor",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "compare",
        "type": "(x : Nat64, y : Nat64) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "equal",
        "type": "(x : Nat64, y : Nat64) : Bool"
      },
      {
        "name": "fromIntWrap",
        "type": ": Int -> Nat64"
      },
      {
        "name": "fromNat",
        "type": ": Nat -> Nat64"
      },
      {
        "name": "fromNat32",
        "type": "(x : Nat32) : Nat64"
      },
      {
        "name": "greater",
        "type": "(x : Nat64, y : Nat64) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Nat64, y : Nat64) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Nat64, y : Nat64) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Nat64, y : Nat64) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "maxValue",
        "type": ": Nat64"
      },
      {
        "name": "min",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "mul",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "mulWrap",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "notEqual",
        "type": "(x : Nat64, y : Nat64) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "powWrap",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Nat64, toExclusive : Nat64) : Iter.Iter<Nat64>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Nat64, to : Nat64) : Iter.Iter<Nat64>"
      },
      {
        "name": "rem",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "sub",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "subWrap",
        "type": "(x : Nat64, y : Nat64) : Nat64"
      },
      {
        "name": "toNat",
        "type": ": Nat64 -> Nat"
      },
      {
        "name": "toNat32",
        "type": "(x : Nat64) : Nat32"
      },
      {
        "name": "toText",
        "type": "(x : Nat64) : Text"
      }
    ]
  },
  {
    "name": "Nat8",
    "functions": [
      {
        "name": "add",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "addWrap",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Nat8>"
      },
      {
        "name": "bitand",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "bitclear",
        "type": "(x : Nat8, p : Nat) : Nat8"
      },
      {
        "name": "bitcountLeadingZero",
        "type": ": (x : Nat8) -> Nat8"
      },
      {
        "name": "bitcountNonZero",
        "type": ": (x : Nat8) -> Nat8"
      },
      {
        "name": "bitcountTrailingZero",
        "type": ": (x : Nat8) -> Nat8"
      },
      {
        "name": "bitflip",
        "type": "(x : Nat8, p : Nat) : Nat8"
      },
      {
        "name": "bitnot",
        "type": "(x : Nat8) : Nat8"
      },
      {
        "name": "bitor",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "bitrotLeft",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "bitrotRight",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "bitset",
        "type": "(x : Nat8, p : Nat) : Nat8"
      },
      {
        "name": "bitshiftLeft",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "bitshiftRight",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "bittest",
        "type": "(x : Nat8, p : Nat) : Bool"
      },
      {
        "name": "bitxor",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "compare",
        "type": "(x : Nat8, y : Nat8) : { #less; #equal; #greater }"
      },
      {
        "name": "div",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "equal",
        "type": "(x : Nat8, y : Nat8) : Bool"
      },
      {
        "name": "fromIntWrap",
        "type": ": Int -> Nat8"
      },
      {
        "name": "fromNat",
        "type": ": Nat -> Nat8"
      },
      {
        "name": "fromNat16",
        "type": ": Nat16 -> Nat8"
      },
      {
        "name": "greater",
        "type": "(x : Nat8, y : Nat8) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(x : Nat8, y : Nat8) : Bool"
      },
      {
        "name": "less",
        "type": "(x : Nat8, y : Nat8) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(x : Nat8, y : Nat8) : Bool"
      },
      {
        "name": "max",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "maxValue",
        "type": ": Nat8"
      },
      {
        "name": "min",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "mul",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "mulWrap",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "notEqual",
        "type": "(x : Nat8, y : Nat8) : Bool"
      },
      {
        "name": "pow",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "powWrap",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "range",
        "type": "(fromInclusive : Nat8, toExclusive : Nat8) : Iter.Iter<Nat8>"
      },
      {
        "name": "rangeInclusive",
        "type": "(from : Nat8, to : Nat8) : Iter.Iter<Nat8>"
      },
      {
        "name": "rem",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "sub",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "subWrap",
        "type": "(x : Nat8, y : Nat8) : Nat8"
      },
      {
        "name": "toNat",
        "type": ": Nat8 -> Nat"
      },
      {
        "name": "toNat16",
        "type": ": Nat8 -> Nat16"
      },
      {
        "name": "toText",
        "type": "(x : Nat8) : Text"
      }
    ]
  },
  {
    "name": "Option",
    "functions": [
      {
        "name": "apply",
        "type": "<A, B>(x : ?A, f : ?(A -> B)) : ?B"
      },
      {
        "name": "chain",
        "type": "<A, B>(x : ?A, f : A -> ?B) : ?B"
      },
      {
        "name": "equal",
        "type": "<A>(x : ?A, y : ?A, eq : (A, A) -> Bool) : Bool"
      },
      {
        "name": "flatten",
        "type": "<A>(x : ??A) : ?A"
      },
      {
        "name": "forEach",
        "type": "<A>(x : ?A, f : A -> ())"
      },
      {
        "name": "get",
        "type": "<T>(x : ?T, default : T) : T"
      },
      {
        "name": "getMapped",
        "type": "<A, B>(x : ?A, f : A -> B, default : B) : B"
      },
      {
        "name": "isNull",
        "type": "(x : ?Any) : Bool"
      },
      {
        "name": "isSome",
        "type": "(x : ?Any) : Bool"
      },
      {
        "name": "map",
        "type": "<A, B>(x : ?A, f : A -> B) : ?B"
      },
      {
        "name": "some",
        "type": "<A>(x : A) : ?A"
      },
      {
        "name": "unwrap",
        "type": "<T>(x : ?T) : T"
      }
    ]
  },
  {
    "name": "Order",
    "functions": [
      {
        "name": "allValues",
        "type": "() : Iter.Iter<Order>"
      },
      {
        "name": "equal",
        "type": "(o1 : Order, o2 : Order) : Bool"
      },
      {
        "name": "isEqual",
        "type": "(order : Order) : Bool"
      },
      {
        "name": "isGreater",
        "type": "(order : Order) : Bool"
      },
      {
        "name": "isLess",
        "type": "(order : Order) : Bool"
      }
    ]
  },
  {
    "name": "Principal",
    "functions": [
      {
        "name": "anonymous",
        "type": "() : Principal"
      },
      {
        "name": "compare",
        "type": "(principal1 : Principal, principal2 : Principal) : { #less; #equal; #greater }"
      },
      {
        "name": "equal",
        "type": "(principal1 : Principal, principal2 : Principal) : Bool"
      },
      {
        "name": "fromActor",
        "type": "(a : actor"
      },
      {
        "name": "fromBlob",
        "type": "(b : Blob) : Principal"
      },
      {
        "name": "fromText",
        "type": "(t : Text) : Principal"
      },
      {
        "name": "greater",
        "type": "(principal1 : Principal, principal2 : Principal) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(principal1 : Principal, principal2 : Principal) : Bool"
      },
      {
        "name": "hash",
        "type": "(principal : Principal) : Hash.Hash"
      },
      {
        "name": "isAnonymous",
        "type": "(p : Principal) : Bool"
      },
      {
        "name": "isController",
        "type": "(p : Principal) : Bool"
      },
      {
        "name": "less",
        "type": "(principal1 : Principal, principal2 : Principal) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(principal1 : Principal, principal2 : Principal) : Bool"
      },
      {
        "name": "notEqual",
        "type": "(principal1 : Principal, principal2 : Principal) : Bool"
      },
      {
        "name": "reset",
        "type": "()"
      },
      {
        "name": "sum",
        "type": "() : Blob"
      },
      {
        "name": "toBlob",
        "type": "(p : Principal) : Blob"
      },
      {
        "name": "toLedgerAccount",
        "type": "(principal : Principal, subAccount : ?Blob) : Blob"
      },
      {
        "name": "toText",
        "type": "(p : Principal) : Text"
      },
      {
        "name": "writeArray",
        "type": "(arr : [Nat8]) : ()"
      },
      {
        "name": "writeBlob",
        "type": "(blob : Blob) : ()"
      },
      {
        "name": "writeIter",
        "type": "(iter : { next() : ?Nat8 }) : ()"
      }
    ]
  },
  {
    "name": "Queue",
    "functions": [
      {
        "name": "all",
        "type": "<T>(queue : Queue<T>, predicate : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(queue : Queue<T>, predicate : T -> Bool) : Bool"
      },
      {
        "name": "clone",
        "type": "<T>(queue : Queue<T>) : Queue<T>"
      },
      {
        "name": "compare",
        "type": "<T>(queue1 : Queue<T>, queue2 : Queue<T>, compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "contains",
        "type": "<T>(queue : Queue<T>, item : T) : Bool"
      },
      {
        "name": "empty",
        "type": "<T>() : Queue<T>"
      },
      {
        "name": "equal",
        "type": "<T>(queue1 : Queue<T>, queue2 : Queue<T>) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(queue : Queue<T>, f : T -> Bool) : Queue<T>"
      },
      {
        "name": "filterMap",
        "type": "<T, U>(queue : Queue<T>, f : T -> ?U) : Queue<U>"
      },
      {
        "name": "forEach",
        "type": "<T>(queue : Queue<T>, f : T -> ())"
      },
      {
        "name": "freeze",
        "type": "<T>(queue : Queue<T>) : Immutable.Queue<T>"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : Iter.Iter<T>) : Queue<T>"
      },
      {
        "name": "isEmpty",
        "type": "<T>(queue : Queue<T>) : Bool"
      },
      {
        "name": "map",
        "type": "<T1, T2>(queue : Queue<T1>, f : T1 -> T2) : Queue<T2>"
      },
      {
        "name": "peekBack",
        "type": "<T>(queue : Queue<T>) : ?T"
      },
      {
        "name": "peekFront",
        "type": "<T>(queue : Queue<T>) : ?T"
      },
      {
        "name": "pop",
        "type": "<T>(queue : Queue<T>) : ?T"
      },
      {
        "name": "popBack",
        "type": "<T>(queue : Queue<T>) : ?T"
      },
      {
        "name": "popFront",
        "type": "<T>(queue : Queue<T>) : ?T"
      },
      {
        "name": "push",
        "type": "<T>(queue : Queue<T>, element : T) : ()"
      },
      {
        "name": "pushBack",
        "type": "<T>(queue : Queue<T>, element : T) : ()"
      },
      {
        "name": "pushFront",
        "type": "<T>(queue : Queue<T>, element : T) : ()"
      },
      {
        "name": "singleton",
        "type": "<T>(item : T) : Queue<T>"
      },
      {
        "name": "size",
        "type": "<T>(queue : Queue<T>) : Nat"
      },
      {
        "name": "thaw",
        "type": "<T>(queue : Immutable.Queue<T>) : Queue<T>"
      },
      {
        "name": "toText",
        "type": "<T>(queue : Queue<T>, f : T -> Text) : Text"
      },
      {
        "name": "values",
        "type": "<T>(queue : Queue<T>) : Iter.Iter<T>"
      }
    ]
  },
  {
    "name": "Random",
    "functions": [
      {
        "name": "AsyncRandom",
        "type": "(generator : () -> async* Blob)"
      },
      {
        "name": "blob",
        "type": ": shared () -> async Blob"
      },
      {
        "name": "bool",
        "type": "() : Bool"
      },
      {
        "name": "bool",
        "type": "() : async* Bool"
      },
      {
        "name": "byte",
        "type": "() : Nat8"
      },
      {
        "name": "byte",
        "type": "() : async* Nat8"
      },
      {
        "name": "float",
        "type": "() : Float"
      },
      {
        "name": "float",
        "type": "() : async* Float"
      },
      {
        "name": "intRange",
        "type": "(min : Int, maxExclusive : Int) : Int"
      },
      {
        "name": "intRange",
        "type": "(min : Int, maxExclusive : Int) : async* Int"
      },
      {
        "name": "natRange",
        "type": "(min : Nat, maxExclusive : Nat) : Nat"
      },
      {
        "name": "natRange",
        "type": "(min : Nat, maxExclusive : Nat) : async* Nat"
      },
      {
        "name": "new",
        "type": "(seed : Blob) : Random"
      },
      {
        "name": "newAsync",
        "type": "() : AsyncRandom"
      },
      {
        "name": "Random",
        "type": "(generator : () -> Blob)"
      }
    ]
  },
  {
    "name": "Region",
    "functions": [
      {
        "name": "grow",
        "type": ": (region : Region, newPages : Nat64) -> (oldPages : Nat64)"
      },
      {
        "name": "id",
        "type": ": Region -> Nat"
      },
      {
        "name": "loadBlob",
        "type": ": (region : Region, offset : Nat64, size : Nat) -> Blob"
      },
      {
        "name": "loadFloat",
        "type": ": (region : Region, offset : Nat64) -> Float"
      },
      {
        "name": "loadInt16",
        "type": ": (region : Region, offset : Nat64) -> Int16"
      },
      {
        "name": "loadInt32",
        "type": ": (region : Region, offset : Nat64) -> Int32"
      },
      {
        "name": "loadInt64",
        "type": ": (region : Region, offset : Nat64) -> Int64"
      },
      {
        "name": "loadInt8",
        "type": ": (region : Region, offset : Nat64) -> Int8"
      },
      {
        "name": "loadNat16",
        "type": ": (region : Region, offset : Nat64) -> Nat16"
      },
      {
        "name": "loadNat32",
        "type": ": (region : Region, offset : Nat64) -> Nat32"
      },
      {
        "name": "loadNat64",
        "type": ": (region : Region, offset : Nat64) -> Nat64"
      },
      {
        "name": "loadNat8",
        "type": ": (region : Region, offset : Nat64) -> Nat8"
      },
      {
        "name": "new",
        "type": ": () -> Region"
      },
      {
        "name": "size",
        "type": ": (region : Region) -> (pages : Nat64)"
      },
      {
        "name": "storeBlob",
        "type": ": (region : Region, offset : Nat64, value : Blob) -> ()"
      },
      {
        "name": "storeFloat",
        "type": ": (region: Region, offset : Nat64, value : Float) -> ()"
      },
      {
        "name": "storeInt16",
        "type": ": (region : Region, offset : Nat64, value : Int16) -> ()"
      },
      {
        "name": "storeInt32",
        "type": ": (region : Region, offset : Nat64, value : Int32) -> ()"
      },
      {
        "name": "storeInt64",
        "type": ": (region : Region, offset : Nat64, value : Int64) -> ()"
      },
      {
        "name": "storeInt8",
        "type": ": (region : Region, offset : Nat64, value : Int8) -> ()"
      },
      {
        "name": "storeNat16",
        "type": ": (region : Region, offset : Nat64, value : Nat16) -> ()"
      },
      {
        "name": "storeNat32",
        "type": ": (region : Region, offset : Nat64, value : Nat32) -> ()"
      },
      {
        "name": "storeNat64",
        "type": ": (region : Region, offset : Nat64, value : Nat64) -> ()"
      },
      {
        "name": "storeNat8",
        "type": ": (region : Region, offset : Nat64, value : Nat8) -> ()"
      }
    ]
  },
  {
    "name": "Result",
    "functions": [
      {
        "name": "assertErr",
        "type": "(r : Result<Any, Any>)"
      },
      {
        "name": "assertOk",
        "type": "(r : Result<Any, Any>)"
      },
      {
        "name": "chain",
        "type": "<R1, R2, Error>( x : Result<R1, Error>, y : R1 -> Result<R2, Error> ) : Result<R2, Error>"
      },
      {
        "name": "compare",
        "type": "<Ok, Err>( compareOk : (Ok, Ok) -> Order.Order, compareErr : (Err, Err) -> Order.Order, r1 : Result<Ok, Err>, r2 : Result<Ok, Err> ) : Order.Order"
      },
      {
        "name": "equal",
        "type": "<Ok, Err>( eqOk : (Ok, Ok) -> Bool, eqErr : (Err, Err) -> Bool, r1 : Result<Ok, Err>, r2 : Result<Ok, Err> ) : Bool"
      },
      {
        "name": "flatten",
        "type": "<Ok, Error>( result : Result<Result<Ok, Error>, Error> ) : Result<Ok, Error>"
      },
      {
        "name": "fromOption",
        "type": "<R, E>(x : ?R, err : E) : Result<R, E>"
      },
      {
        "name": "fromUpper",
        "type": "<Ok, Err>( result : { #Ok: Ok; #Err: Err } ) : Result<Ok, Err>"
      },
      {
        "name": "isErr",
        "type": "(r : Result<Any, Any>) : Bool"
      },
      {
        "name": "isOk",
        "type": "(r : Result<Any, Any>) : Bool"
      },
      {
        "name": "iterate",
        "type": "<Ok, Err>(res : Result<Ok, Err>, f : Ok -> ())"
      },
      {
        "name": "mapErr",
        "type": "<Ok, Error1, Error2>( x : Result<Ok, Error1>, f : Error1 -> Error2 ) : Result<Ok, Error2>"
      },
      {
        "name": "mapOk",
        "type": "<Ok1, Ok2, Error>( x : Result<Ok1, Error>, f : Ok1 -> Ok2 ) : Result<Ok2, Error>"
      },
      {
        "name": "toOption",
        "type": "<R, E>(r : Result<R, E>) : ?R"
      },
      {
        "name": "toUpper",
        "type": "<Ok, Err>( result : Result<Ok, Err> ) : { #Ok: Ok; #Err: Err }"
      }
    ]
  },
  {
    "name": "Runtime",
    "functions": [
      {
        "name": "foo",
        "type": "() : async ()"
      },
      {
        "name": "trap",
        "type": "(errorMessage : Text) : None"
      },
      {
        "name": "unreachable",
        "type": "() : None"
      }
    ]
  },
  {
    "name": "Set",
    "functions": [
      {
        "name": "add",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order, item : T) : ()"
      },
      {
        "name": "all",
        "type": "<T>(set : Set<T>, pred : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(set : Set<T>, pred : T -> Bool) : Bool"
      },
      {
        "name": "assertValid",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order) : ()"
      },
      {
        "name": "clone",
        "type": "<T>(set : Set<T>) : Set<T>"
      },
      {
        "name": "compare",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>, compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "contains",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order, item : T) : Bool"
      },
      {
        "name": "delete",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order, item : T) : Bool"
      },
      {
        "name": "diff",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Set<T>"
      },
      {
        "name": "empty",
        "type": "<T>() : Set<T>"
      },
      {
        "name": "equal",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>, equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(set : Set<T>, f : T -> Bool) : Set<T>"
      },
      {
        "name": "filterMap",
        "type": "<T1, T2>(set : Set<T1>, f : T1 -> ?T2) : Set<T2>"
      },
      {
        "name": "flatten",
        "type": "<T>(set : Iter.Iter<Set<T>>) : Set<T>"
      },
      {
        "name": "foldLeft",
        "type": "<T, A>( set : Set<T>, base : A, combine : (A, T) -> A ) : A"
      },
      {
        "name": "foldRight",
        "type": "<T, A>( set : Set<T>, base : A, combine : (A, T) -> A ) : A"
      },
      {
        "name": "forEach",
        "type": "<T>(set : Set<T>, f : T -> ())"
      },
      {
        "name": "freeze",
        "type": "<T>(set : Set<T>) : Immutable.Set<T>"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : Iter.Iter<T>, compare : (T, T) -> Order.Order) : Set<T>"
      },
      {
        "name": "intersect",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Set<T>"
      },
      {
        "name": "isEmpty",
        "type": "(set : Set<Any>) : Bool"
      },
      {
        "name": "isSubset",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Bool"
      },
      {
        "name": "map",
        "type": "<T1, T2>(set : Set<T1>, f : T1 -> T2) : Set<T2>"
      },
      {
        "name": "max",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order) : ?T"
      },
      {
        "name": "min",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order) : ?T"
      },
      {
        "name": "reverseValues",
        "type": "<T>(set : Set<T>) : Iter.Iter<T>"
      },
      {
        "name": "singleton",
        "type": "<T>() : Set<T>"
      },
      {
        "name": "size",
        "type": "(set : Set<Any>) : Nat"
      },
      {
        "name": "thaw",
        "type": "<T>(set : Immutable.Set<T>) : Set<T>"
      },
      {
        "name": "toText",
        "type": "<T>(set : Set<T>, f : T -> Text) : Text"
      },
      {
        "name": "union",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Set<T>"
      },
      {
        "name": "values",
        "type": "<T>(set : Set<T>) : Iter.Iter<T>"
      }
    ]
  },
  {
    "name": "Stack",
    "functions": [
      {
        "name": "all",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : Bool"
      },
      {
        "name": "chunks",
        "type": "<T>(stack : Stack<T>, n : Nat) : Stack<Stack<T>>"
      },
      {
        "name": "clone",
        "type": "<T>(stack : Stack<T>) : Stack<T>"
      },
      {
        "name": "compare",
        "type": "<T>(stack1 : Stack<T>, stack2 : Stack<T>, compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "concat",
        "type": "<T>(stack1 : Stack<T>, stack2 : Stack<T>) : Stack<T>"
      },
      {
        "name": "contains",
        "type": "<T>(stack : Stack<T>, item : T) : Bool"
      },
      {
        "name": "drop",
        "type": "<T>(stack : Stack<T>, n : Nat) : Stack<T>"
      },
      {
        "name": "empty",
        "type": "<T>() : Stack<T>"
      },
      {
        "name": "equal",
        "type": "<T>(stack1 : Stack<T>, stack2 : Stack<T>) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : Stack<T>"
      },
      {
        "name": "filterMap",
        "type": "<T, U>(stack : Stack<T>, f : T -> ?U) : Stack<U>"
      },
      {
        "name": "find",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : ?T"
      },
      {
        "name": "flatten",
        "type": "<T>(stack : Iter.Iter<Stack<T>>) : Stack<T>"
      },
      {
        "name": "foldLeft",
        "type": "<T, A>(stack : Stack<T>, base : A, combine : (A, T) -> A) : A"
      },
      {
        "name": "foldRight",
        "type": "<T, A>(stack : Stack<T>, base : A, combine : (T, A) -> A) : A"
      },
      {
        "name": "forEach",
        "type": "<T>(stack : Stack<T>, f : T -> ())"
      },
      {
        "name": "freeze",
        "type": "<T>(stack : Stack<T>) : Immutable.Stack<T>"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : Iter.Iter<T>) : Stack<T>"
      },
      {
        "name": "generate",
        "type": "<T>(n : Nat, f : Nat -> T) : Stack<T>"
      },
      {
        "name": "get",
        "type": "<T>(stack : Stack<T>, n : Nat) : ?T"
      },
      {
        "name": "isEmpty",
        "type": "(stack : Stack<Any>) : Bool"
      },
      {
        "name": "map",
        "type": "<T1, T2>(stack : Stack<T1>, f : T1 -> T2) : Stack<T2>"
      },
      {
        "name": "mapResult",
        "type": "<T, R, E>(stack : Stack<T>, f : T -> Result.Result<R, E>) : Result.Result<Stack<R>, E>"
      },
      {
        "name": "merge",
        "type": "<T>(stack1 : Stack<T>, stack2 : Stack<T>, lessThanOrEqual : (T, T) -> Bool) : Stack<T>"
      },
      {
        "name": "partition",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : (Stack<T>, Stack<T>)"
      },
      {
        "name": "peek",
        "type": "<T>(stack : Stack<T>) : ?T"
      },
      {
        "name": "pop",
        "type": "<T>(stack : Stack<T>) : ?T"
      },
      {
        "name": "push",
        "type": "<T>(stack : Stack<T>, item : T) : ()"
      },
      {
        "name": "repeat",
        "type": "<T>(item : T, n : Nat) : Stack<T>"
      },
      {
        "name": "reverse",
        "type": "<T>(stack : Stack<T>) : ()"
      },
      {
        "name": "singleton",
        "type": "<T>(item : T) : Stack<T>"
      },
      {
        "name": "size",
        "type": "(stack : Stack<Any>) : Nat"
      },
      {
        "name": "split",
        "type": "<T>(stack : Stack<T>, n : Nat) : (Stack<T>, Stack<T>)"
      },
      {
        "name": "take",
        "type": "<T>(stack : Stack<T>, n : Nat) : Stack<T>"
      },
      {
        "name": "thaw",
        "type": "<T>(stack : Immutable.Stack<T>) : Stack<T>"
      },
      {
        "name": "toText",
        "type": "<T>(stack : Stack<T>, f : T -> Text) : Text"
      },
      {
        "name": "values",
        "type": "<T>(stack : Stack<T>) : Iter.Iter<T>"
      },
      {
        "name": "zip",
        "type": "<T, U>(stack1 : Stack<T>, stack2 : Stack<U>) : Stack<(T, U)>"
      },
      {
        "name": "zipWith",
        "type": "<T, U, V>(stack1 : Stack<T>, stack2 : Stack<U>, f : (T, U) -> V) : Stack<V>"
      }
    ]
  },
  {
    "name": "Text",
    "functions": [
      {
        "name": "compare",
        "type": "(t1 : Text, t2 : Text) : { #less; #equal; #greater }"
      },
      {
        "name": "compareWith",
        "type": "( t1 : Text, t2 : Text, cmp : (Char, Char) ->"
      },
      {
        "name": "concat",
        "type": "(t1 : Text, t2 : Text) : Text"
      },
      {
        "name": "contains",
        "type": "(t : Text, p : Pattern) : Bool"
      },
      {
        "name": "decodeUtf8",
        "type": ": Blob -> ?Text"
      },
      {
        "name": "encodeUtf8",
        "type": ": Text -> Blob"
      },
      {
        "name": "endsWith",
        "type": "(t : Text, p : Pattern) : Bool"
      },
      {
        "name": "equal",
        "type": "(t1 : Text, t2 : Text) : Bool"
      },
      {
        "name": "fromArray",
        "type": "(a : [Char]) : Text"
      },
      {
        "name": "fromChar",
        "type": ": (c : Char) -> Text"
      },
      {
        "name": "fromIter",
        "type": "(cs : Iter.Iter<Char>) : Text"
      },
      {
        "name": "fromList",
        "type": "(cs : List.List<Char>) : Text"
      },
      {
        "name": "fromVarArray",
        "type": "(a : [var Char]) : Text"
      },
      {
        "name": "greater",
        "type": "(t1 : Text, t2 : Text) : Bool"
      },
      {
        "name": "greaterOrEqual",
        "type": "(t1 : Text, t2 : Text) : Bool"
      },
      {
        "name": "hash",
        "type": "(t : Text) : Hash.Hash"
      },
      {
        "name": "join",
        "type": "(sep : Text, ts : Iter.Iter<Text>) : Text"
      },
      {
        "name": "less",
        "type": "(t1 : Text, t2 : Text) : Bool"
      },
      {
        "name": "lessOrEqual",
        "type": "(t1 : Text, t2 : Text) : Bool"
      },
      {
        "name": "map",
        "type": "(t : Text, f : Char -> Char) : Text"
      },
      {
        "name": "next",
        "type": "() : ?Char"
      },
      {
        "name": "next",
        "type": "() : ?Char"
      },
      {
        "name": "next",
        "type": "() : ?Char"
      },
      {
        "name": "next",
        "type": "() : ?Text"
      },
      {
        "name": "next",
        "type": "() : ?Text"
      },
      {
        "name": "notEqual",
        "type": "(t1 : Text, t2 : Text) : Bool"
      },
      {
        "name": "pushBack",
        "type": "(cs0 : Iter.Iter<Char>, c : Char)"
      },
      {
        "name": "replace",
        "type": "(t : Text, p : Pattern, r : Text) : Text"
      },
      {
        "name": "size",
        "type": "(t : Text) : Nat"
      },
      {
        "name": "split",
        "type": "(t : Text, p : Pattern) : Iter.Iter<Text>"
      },
      {
        "name": "startsWith",
        "type": "(t : Text, p : Pattern) : Bool"
      },
      {
        "name": "stripEnd",
        "type": "(t : Text, p : Pattern) : ?Text"
      },
      {
        "name": "stripStart",
        "type": "(t : Text, p : Pattern) : ?Text"
      },
      {
        "name": "toArray",
        "type": "(t : Text) : [Char]"
      },
      {
        "name": "toIter",
        "type": "(t : Text) : Iter.Iter<Char>"
      },
      {
        "name": "tokens",
        "type": "(t : Text, p : Pattern) : Iter.Iter<Text>"
      },
      {
        "name": "toList",
        "type": "(t : Text) : List.List<Char>"
      },
      {
        "name": "toLowercase",
        "type": ": Text -> Text"
      },
      {
        "name": "toUppercase",
        "type": ": Text -> Text"
      },
      {
        "name": "toVarArray",
        "type": "(t : Text) : [var Char]"
      },
      {
        "name": "translate",
        "type": "(t : Text, f : Char -> Text) : Text"
      },
      {
        "name": "trim",
        "type": "(t : Text, p : Pattern) : Text"
      },
      {
        "name": "trimEnd",
        "type": "(t : Text, p : Pattern) : Text"
      },
      {
        "name": "trimStart",
        "type": "(t : Text, p : Pattern) : Text"
      }
    ]
  },
  {
    "name": "Time",
    "functions": [
      {
        "name": "greet",
        "type": "(name : Text) : async Text"
      },
      {
        "name": "now",
        "type": ": () -> Time"
      },
      {
        "name": "toNanoseconds",
        "type": "(duration : Duration) : Nat"
      }
    ]
  },
  {
    "name": "Timer",
    "functions": [
      {
        "name": "cancelTimer",
        "type": ": TimerId -> ()"
      },
      {
        "name": "recurringTimer",
        "type": "<system>(duration : Time.Duration, job : () -> async ()) : TimerId"
      },
      {
        "name": "setTimer",
        "type": "<system>(duration : Time.Duration, job : () -> async ()) : TimerId"
      }
    ]
  },
  {
    "name": "VarArray",
    "functions": [
      {
        "name": "all",
        "type": "<T>(array : [var T], predicate : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(array : [var T], predicate : T -> Bool) : Bool"
      },
      {
        "name": "append",
        "type": "<T>(array1 : [var T], array2 : [var T]) : [var T]"
      },
      {
        "name": "chain",
        "type": "<T, Y>(array : [var T], k : T -> [var Y]) : [var Y]"
      },
      {
        "name": "compare",
        "type": "<T>(array1 : [var T], array2 : [var T], compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "empty",
        "type": "<T>() : [var T]"
      },
      {
        "name": "equal",
        "type": "<T>(array1 : [var T], array2 : [var T], equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(array : [var T], f : T -> Bool) : [var T]"
      },
      {
        "name": "filterMap",
        "type": "<T, Y>(array : [var T], f : T -> ?Y) : [var Y]"
      },
      {
        "name": "find",
        "type": "<T>(array : [var T], predicate : T -> Bool) : ?T"
      },
      {
        "name": "flatten",
        "type": "<T>(arrays : Iter.Iter<[var T]>) : [var T]"
      },
      {
        "name": "foldLeft",
        "type": "<T, A>(array : [var T], base : A, combine : (A, T) -> A) : A"
      },
      {
        "name": "foldRight",
        "type": "<T, A>(array : [var T], base : A, combine : (T, A) -> A) : A"
      },
      {
        "name": "forEach",
        "type": "<T>(array : [var T], f : T -> ())"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : Iter.Iter<T>) : [var T]"
      },
      {
        "name": "generate",
        "type": "<T>(size : Nat, generator : Nat -> T) : [var T]"
      },
      {
        "name": "indexOf",
        "type": "<T>(element : T, array : [var T], equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "init",
        "type": "<T>(size : Nat, initValue : T) : [var T]"
      },
      {
        "name": "isEmpty",
        "type": "<T>(array : [var T]) : Bool"
      },
      {
        "name": "keys",
        "type": "<T>(array : [var T]) : Iter.Iter<Nat>"
      },
      {
        "name": "lastIndexOf",
        "type": "<T>(element : T, array : [var T], equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "map",
        "type": "<T, Y>(array : [var T], f : T -> Y) : [var Y]"
      },
      {
        "name": "mapEntries",
        "type": "<T, Y>(array : [var T], f : (T, Nat) -> Y) : [var Y]"
      },
      {
        "name": "mapResult",
        "type": "<T, Y, E>(array : [var T], f : T -> Result.Result<Y, E>) : Result.Result<[var Y], E>"
      },
      {
        "name": "nextIndexOf",
        "type": "<T>(element : T, array : [var T], fromInclusive : Nat, equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "prevIndexOf",
        "type": "<T>(element : T, array : [var T], fromExclusive : Nat, equal : (T, T) -> Bool) : ?Nat"
      },
      {
        "name": "reverse",
        "type": "<T>(array : [var T]) : [var T]"
      },
      {
        "name": "reverseInPlace",
        "type": "<T>(array : [var T]) : ()"
      },
      {
        "name": "singleton",
        "type": "<T>(element : T) : [var T]"
      },
      {
        "name": "size",
        "type": "<T>(array : [var T]) : Nat"
      },
      {
        "name": "slice",
        "type": "<T>(array : [var T], fromInclusive : Int, toExclusive : Int) : Iter.Iter<T>"
      },
      {
        "name": "sort",
        "type": "<T>(array : [var T], compare : (T, T) -> Order.Order) : [var T]"
      },
      {
        "name": "sortInPlace",
        "type": "<T>(array : [var T], compare : (T, T) -> Order.Order) : ()"
      },
      {
        "name": "subArray",
        "type": "<T>(array : [var T], start : Nat, length : Nat) : [var T]"
      },
      {
        "name": "toText",
        "type": "<T>(array : [var T], f : T -> Text) : Text"
      },
      {
        "name": "values",
        "type": "<T>(array : [var T]) : Iter.Iter<T>"
      }
    ]
  },
  {
    "name": "immutable/Map",
    "functions": [
      {
        "name": "add",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K, value : V) : Map<K, V>"
      },
      {
        "name": "all",
        "type": "<K, V>(map : Map<K, V>, pred : (K, V) -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<K, V>(map : Map<K, V>, pred : (K, V) -> Bool) : Bool"
      },
      {
        "name": "assertValid",
        "type": "<K>(map : Map<K, Any>, compare : (K, K) -> Order.Order) : ()"
      },
      {
        "name": "containsKey",
        "type": "<K>(map : Map<K, Any>, compare : (K, K) -> Order.Order, key : K) : Bool"
      },
      {
        "name": "delete",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K) : Map<K, V>"
      },
      {
        "name": "empty",
        "type": "<K, V>() : Map<K, V>"
      },
      {
        "name": "entries",
        "type": "<K, V>(map : Map<K, V>) : Iter.Iter<(K, V)>"
      },
      {
        "name": "filterMap",
        "type": "<K, V1, V2>(map : Map<K, V1>, f : (K, V1) -> ?V2) : Map<K, V2>"
      },
      {
        "name": "foldLeft",
        "type": "<K, V, A>( map : Map<K, V>, base : A, combine : (A, K, V) -> A ) : A"
      },
      {
        "name": "foldRight",
        "type": "<K, V, A>( map : Map<K, V>, base : A, combine : (K, V, A) -> A ) : A"
      },
      {
        "name": "fromIter",
        "type": "<K, V>(iter : Iter.Iter<(K, V)>, compare : (K, K) -> Order.Order) : Map<K, V>"
      },
      {
        "name": "get",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K) : ?V"
      },
      {
        "name": "isEmpty",
        "type": "(map : Map<Any, Any>) : Bool"
      },
      {
        "name": "keys",
        "type": "<K>(map : Map<K, Any>) : Iter.Iter<K>"
      },
      {
        "name": "map",
        "type": "<K, V1, V2>(map : Map<K, V1>, f : (K, V1) -> V2) : Map<K, V2>"
      },
      {
        "name": "maxEntry",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order) : ?(K, V)"
      },
      {
        "name": "minEntry",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order) : ?(K, V)"
      },
      {
        "name": "put",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K, value : V) : (Map<K, V>, ?V)"
      },
      {
        "name": "reverseEntries",
        "type": "<K, V>(map : Map<K, V>) : Iter.Iter<(K, V)>"
      },
      {
        "name": "size",
        "type": "(map : Map<Any, Any>) : Nat"
      },
      {
        "name": "take",
        "type": "<K, V>(map : Map<K, V>, compare : (K, K) -> Order.Order, key : K) : (Map<K, V>, ?V)"
      },
      {
        "name": "toText",
        "type": "<K, V>(set : Map<K, V>, kf : K -> Text, vf : V -> Text) : Text"
      },
      {
        "name": "values",
        "type": "<V>(map : Map<Any, V>) : Iter.Iter<V>"
      }
    ]
  },
  {
    "name": "immutable/Queue",
    "functions": [
      {
        "name": "all",
        "type": "<T>(queue : Queue<T>, predicate : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(queue : Queue<T>, predicate : T -> Bool) : Bool"
      },
      {
        "name": "compare",
        "type": "<T>(queue1 : Queue<T>, queue2 : Queue<T>, compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "contains",
        "type": "<T>(queue : Queue<T>, item : T) : Bool"
      },
      {
        "name": "empty",
        "type": "<T>() : Queue<T>"
      },
      {
        "name": "equal",
        "type": "<T>(queue1 : Queue<T>, queue2 : Queue<T>) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(queue : Queue<T>, f : T -> Bool) : Queue<T>"
      },
      {
        "name": "filterMap",
        "type": "<T, U>(queue : Queue<T>, f : T -> ?U) : Queue<U>"
      },
      {
        "name": "forEach",
        "type": "<T>(queue : Queue<T>, f : T -> ())"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : Iter.Iter<T>) : Queue<T>"
      },
      {
        "name": "isEmpty",
        "type": "(queue : Queue<Any>) : Bool"
      },
      {
        "name": "map",
        "type": "<T1, T2>(queue : Queue<T1>, f : T1 -> T2) : Queue<T2>"
      },
      {
        "name": "peekBack",
        "type": "<T>(queue : Queue<T>) : ?T"
      },
      {
        "name": "peekFront",
        "type": "<T>(queue : Queue<T>) : ?T"
      },
      {
        "name": "popBack",
        "type": "<T>(queue : Queue<T>) : ?(Queue<T>, T)"
      },
      {
        "name": "popFront",
        "type": "<T>(queue : Queue<T>) : ?(T, Queue<T>)"
      },
      {
        "name": "pushBack",
        "type": "<T>(queue : Queue<T>, element : T) : Queue<T>"
      },
      {
        "name": "pushFront",
        "type": "<T>(queue : Queue<T>, element : T) : Queue<T>"
      },
      {
        "name": "singleton",
        "type": "<T>(item : T) : Queue<T>"
      },
      {
        "name": "size",
        "type": "(queue : Queue<Any>) : Nat"
      },
      {
        "name": "toText",
        "type": "<T>(queue : Queue<T>, f : T -> Text) : Text"
      },
      {
        "name": "values",
        "type": "<T>(queue : Queue<T>) : Iter.Iter<T>"
      }
    ]
  },
  {
    "name": "immutable/Set",
    "functions": [
      {
        "name": "add",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order, item : T) : Set<T>"
      },
      {
        "name": "all",
        "type": "<T>(set : Set<T>, pred : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(set : Set<T>, pred : T -> Bool) : Bool"
      },
      {
        "name": "assertValid",
        "type": "(set : Set<Any>) : ()"
      },
      {
        "name": "compare",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>, compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "contains",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order, item : T) : Bool"
      },
      {
        "name": "delete",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order, item : T) : Set<T>"
      },
      {
        "name": "diff",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Set<T>"
      },
      {
        "name": "empty",
        "type": "<T>() : Set<T>"
      },
      {
        "name": "equal",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(set : Set<T>, f : T -> Bool) : Set<T>"
      },
      {
        "name": "filterMap",
        "type": "<T1, T2>(set : Set<T1>, f : T1 -> ?T2) : Set<T2>"
      },
      {
        "name": "foldLeft",
        "type": "<T, A>( set : Set<T>, base : A, combine : (A, T) -> A ) : A"
      },
      {
        "name": "foldRight",
        "type": "<T, A>( set : Set<T>, base : A, combine : (A, T) -> A ) : A"
      },
      {
        "name": "forEach",
        "type": "<T>(set : Set<T>, f : T -> ())"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : Iter.Iter<T>, compare : (T, T) -> Order.Order) : Set<T>"
      },
      {
        "name": "intersect",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Set<T>"
      },
      {
        "name": "isEmpty",
        "type": "<T>(set : Set<T>) : Bool"
      },
      {
        "name": "isSubset",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Bool"
      },
      {
        "name": "map",
        "type": "<T1, T2>(set : Set<T1>, f : T1 -> T2) : Set<T2>"
      },
      {
        "name": "max",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order) : ?T"
      },
      {
        "name": "min",
        "type": "<T>(set : Set<T>, compare : (T, T) -> Order.Order) : ?T"
      },
      {
        "name": "reverseValues",
        "type": "<T>(set : Set<T>) : Iter.Iter<T>"
      },
      {
        "name": "singleton",
        "type": "<T>(item : T) : Set<T>"
      },
      {
        "name": "size",
        "type": "<T>(set : Set<T>) : Nat"
      },
      {
        "name": "toText",
        "type": "<T>(set : Set<T>, f : T -> Text) : Text"
      },
      {
        "name": "union",
        "type": "<T>(set1 : Set<T>, set2 : Set<T>) : Set<T>"
      },
      {
        "name": "values",
        "type": "<T>(set : Set<T>) : Iter.Iter<T>"
      }
    ]
  },
  {
    "name": "immutable/Stack",
    "functions": [
      {
        "name": "all",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : Bool"
      },
      {
        "name": "any",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : Bool"
      },
      {
        "name": "chunks",
        "type": "<T>(stack : Stack<T>, n : Nat) : Stack<Stack<T>>"
      },
      {
        "name": "compare",
        "type": "<T>(stack1 : Stack<T>, stack2 : Stack<T>, compare : (T, T) -> Order.Order) : Order.Order"
      },
      {
        "name": "concat",
        "type": "<T>(stack1 : Stack<T>, stack2 : Stack<T>) : Stack<T>"
      },
      {
        "name": "contains",
        "type": "<T>(stack : Stack<T>, item : T) : Bool"
      },
      {
        "name": "drop",
        "type": "<T>(stack : Stack<T>, n : Nat) : Stack<T>"
      },
      {
        "name": "empty",
        "type": "<T>() : Stack<T>"
      },
      {
        "name": "equal",
        "type": "<T>(stack1 : Stack<T>, stack2 : Stack<T>, equal : (T, T) -> Bool) : Bool"
      },
      {
        "name": "filter",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : Stack<T>"
      },
      {
        "name": "filterMap",
        "type": "<T, U>(stack : Stack<T>, f : T -> ?U) : Stack<U>"
      },
      {
        "name": "find",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : ?T"
      },
      {
        "name": "flatten",
        "type": "<T>(stack : Iter.Iter<Stack<T>>) : Stack<T>"
      },
      {
        "name": "foldLeft",
        "type": "<T, A>(stack : Stack<T>, base : A, combine : (A, T) -> A) : A"
      },
      {
        "name": "foldRight",
        "type": "<T, A>(stack : Stack<T>, base : A, combine : (T, A) -> A) : A"
      },
      {
        "name": "forEach",
        "type": "<T>(stack : Stack<T>, f : T -> ())"
      },
      {
        "name": "fromArray",
        "type": "<T>(array : [T]) : Stack<T>"
      },
      {
        "name": "fromIter",
        "type": "<T>(iter : Iter.Iter<T>) : Stack<T>"
      },
      {
        "name": "fromVarArray",
        "type": "<T>(array : [var T]) : Stack<T>"
      },
      {
        "name": "generate",
        "type": "<T>(n : Nat, f : Nat -> T) : Stack<T>"
      },
      {
        "name": "get",
        "type": "<T>(stack : Stack<T>, n : Nat) : ?T"
      },
      {
        "name": "isEmpty",
        "type": "(stack : Stack<Any>) : Bool"
      },
      {
        "name": "map",
        "type": "<T1, T2>(stack : Stack<T1>, f : T1 -> T2) : Stack<T2>"
      },
      {
        "name": "mapResult",
        "type": "<T, R, E>(stack : Stack<T>, f : T -> Result.Result<R, E>) : Result.Result<Stack<R>, E>"
      },
      {
        "name": "merge",
        "type": "<T>(stack1 : Stack<T>, stack2 : Stack<T>, lessThanOrEqual : (T, T) -> Bool) : Stack<T>"
      },
      {
        "name": "partition",
        "type": "<T>(stack : Stack<T>, f : T -> Bool) : (Stack<T>, Stack<T>)"
      },
      {
        "name": "peek",
        "type": "<T>(stack : Stack<T>) : ?T"
      },
      {
        "name": "pop",
        "type": "<T>(stack : Stack<T>) : (?T, Stack<T>)"
      },
      {
        "name": "push",
        "type": "<T>(stack : Stack<T>, item : T) : Stack<T>"
      },
      {
        "name": "repeat",
        "type": "<T>(item : T, n : Nat) : Stack<T>"
      },
      {
        "name": "reverse",
        "type": "<T>(stack : Stack<T>) : Stack<T>"
      },
      {
        "name": "singleton",
        "type": "<T>(item : T) : Stack<T>"
      },
      {
        "name": "size",
        "type": "(stack : Stack<Any>) : Nat"
      },
      {
        "name": "split",
        "type": "<T>(stack : Stack<T>, n : Nat) : (Stack<T>, Stack<T>)"
      },
      {
        "name": "take",
        "type": "<T>(stack : Stack<T>, n : Nat) : Stack<T>"
      },
      {
        "name": "toArray",
        "type": "<T>(stack : Stack<T>) : [T]"
      },
      {
        "name": "toText",
        "type": "<T>(stack : Stack<T>, f : T -> Text) : Text"
      },
      {
        "name": "toVarArray",
        "type": "<T>(stack : Stack<T>) : [var T]"
      },
      {
        "name": "values",
        "type": "<T>(stack : Stack<T>) : Iter.Iter<T>"
      },
      {
        "name": "zip",
        "type": "<T, U>(stack1 : Stack<T>, stack2 : Stack<U>) : Stack<(T, U)>"
      },
      {
        "name": "zipWith",
        "type": "<T, U, V>(stack1 : Stack<T>, stack2 : Stack<U>, f : (T, U) -> V) : Stack<V>"
      }
    ]
  }
]